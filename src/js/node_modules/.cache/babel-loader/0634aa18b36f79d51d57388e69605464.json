{"ast":null,"code":"/*!\n * Core functionality for Snowplow Browser trackers v3.1.0 (http://bit.ly/sp-js)\n * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * Licensed under BSD-3-Clause\n */\nimport { LOG, trackerCore, buildPageView, buildPagePing } from '@snowplow/tracker-core';\nimport { __assign } from 'tslib';\nimport hash from 'sha1';\nimport { v4 } from 'uuid';\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Checks whether sessionStorage is available, in a way that\n * does not throw a SecurityError in Firefox if \"always ask\"\n * is enabled for cookies (https://github.com/snowplow/snowplow/issues/163).\n */\n\nfunction hasSessionStorage() {\n  try {\n    return !!window.sessionStorage;\n  } catch (e) {\n    return true; // SecurityError when referencing it means it exists\n  }\n}\n/*\n * Checks whether localStorage is available, in a way that\n * does not throw a SecurityError in Firefox if \"always ask\"\n * is enabled for cookies (https://github.com/snowplow/snowplow/issues/163).\n */\n\n\nfunction hasLocalStorage() {\n  try {\n    return !!window.localStorage;\n  } catch (e) {\n    return true; // SecurityError when referencing it means it exists\n  }\n}\n/*\n * Checks whether localStorage is accessible\n * sets and removes an item to handle private IOS5 browsing\n * (http://git.io/jFB2Xw)\n */\n\n\nfunction localStorageAccessible() {\n  var mod = 'modernizr';\n\n  if (!hasLocalStorage()) {\n    return false;\n  }\n\n  try {\n    var ls = window.localStorage;\n    ls.setItem(mod, mod);\n    ls.removeItem(mod);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Gets the current viewport.\n *\n * Code based on:\n * - http://andylangton.co.uk/articles/javascript/get-viewport-size-javascript/\n * - http://responsejs.com/labs/dimensions/\n */\n\n\nfunction detectViewport() {\n  var width, height;\n\n  if ('innerWidth' in window) {\n    width = window['innerWidth'];\n    height = window['innerHeight'];\n  } else {\n    var e = document.documentElement || document.body;\n    width = e['clientWidth'];\n    height = e['clientHeight'];\n  }\n\n  if (width >= 0 && height >= 0) {\n    return width + 'x' + height;\n  } else {\n    return null;\n  }\n}\n/**\n * Gets the dimensions of the current\n * document.\n *\n * Code based on:\n * - http://andylangton.co.uk/articles/javascript/get-viewport-size-javascript/\n */\n\n\nfunction detectDocumentSize() {\n  var de = document.documentElement,\n      // Alias\n  be = document.body,\n      // document.body may not have rendered, so check whether be.offsetHeight is null\n  bodyHeight = be ? Math.max(be.offsetHeight, be.scrollHeight) : 0;\n  var w = Math.max(de.clientWidth, de.offsetWidth, de.scrollWidth);\n  var h = Math.max(de.clientHeight, de.offsetHeight, de.scrollHeight, bodyHeight);\n  return isNaN(w) || isNaN(h) ? '' : w + 'x' + h;\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Checks if an object is a string\n * @param str - The object to check\n */\n\n\nfunction isString(str) {\n  if (str && typeof str.valueOf() === 'string') {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if an object is an integer\n * @param int - The object to check\n */\n\n\nfunction isInteger(int) {\n  return Number.isInteger && Number.isInteger(int) || typeof int === 'number' && isFinite(int) && Math.floor(int) === int;\n}\n/**\n * Checks if the input parameter is a function\n * @param func - The object to check\n */\n\n\nfunction isFunction(func) {\n  if (func && typeof func === 'function') {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Cleans up the page title\n */\n\n\nfunction fixupTitle(title) {\n  if (!isString(title)) {\n    title = title.text || '';\n    var tmp = document.getElementsByTagName('title');\n\n    if (tmp && tmp[0] != null) {\n      title = tmp[0].text;\n    }\n  }\n\n  return title;\n}\n/**\n * Extract hostname from URL\n */\n\n\nfunction getHostName(url) {\n  // scheme : // [username [: password] @] hostname [: port] [/ [path] [? query] [# fragment]]\n  var e = new RegExp('^(?:(?:https?|ftp):)/*(?:[^@]+@)?([^:/#]+)'),\n      matches = e.exec(url);\n  return matches ? matches[1] : url;\n}\n/**\n * Fix-up domain\n */\n\n\nfunction fixupDomain(domain) {\n  var dl = domain.length; // remove trailing '.'\n\n  if (domain.charAt(--dl) === '.') {\n    domain = domain.slice(0, dl);\n  } // remove leading '*'\n\n\n  if (domain.slice(0, 2) === '*.') {\n    domain = domain.slice(1);\n  }\n\n  return domain;\n}\n/**\n * Get page referrer. In the case of a single-page app,\n * if the URL changes without the page reloading, pass\n * in the old URL. It will be returned unless overriden\n * by a \"refer(r)er\" parameter in the querystring.\n *\n * @param string - oldLocation Optional.\n * @return string The referrer\n */\n\n\nfunction getReferrer(oldLocation) {\n  var windowAlias = window,\n      referrer = '',\n      fromQs = fromQuerystring('referrer', windowAlias.location.href) || fromQuerystring('referer', windowAlias.location.href); // Short-circuit\n\n  if (fromQs) {\n    return fromQs;\n  } // In the case of a single-page app, return the old URL\n\n\n  if (oldLocation) {\n    return oldLocation;\n  }\n\n  try {\n    referrer = windowAlias.top.document.referrer;\n  } catch (e) {\n    if (windowAlias.parent) {\n      try {\n        referrer = windowAlias.parent.document.referrer;\n      } catch (e2) {\n        referrer = '';\n      }\n    }\n  }\n\n  if (referrer === '') {\n    referrer = document.referrer;\n  }\n\n  return referrer;\n}\n/**\n * Cross-browser helper function to add event handler\n */\n\n\nfunction addEventListener(element, eventType, eventHandler, options) {\n  if (element.addEventListener) {\n    element.addEventListener(eventType, eventHandler, options);\n    return true;\n  } // IE Support\n\n\n  if (element.attachEvent) {\n    return element.attachEvent('on' + eventType, eventHandler);\n  }\n\n  element['on' + eventType] = eventHandler;\n}\n/**\n * Return value from name-value pair in querystring\n */\n\n\nfunction fromQuerystring(field, url) {\n  var match = new RegExp('^[^#]*[?&]' + field + '=([^&#]*)').exec(url);\n\n  if (!match) {\n    return null;\n  }\n\n  return decodeURIComponent(match[1].replace(/\\+/g, ' '));\n}\n/**\n * Add a name-value pair to the querystring of a URL\n *\n * @param string - url URL to decorate\n * @param string - name Name of the querystring pair\n * @param string - value Value of the querystring pair\n */\n\n\nfunction decorateQuerystring(url, name, value) {\n  var initialQsParams = name + '=' + value;\n  var hashSplit = url.split('#');\n  var qsSplit = hashSplit[0].split('?');\n  var beforeQuerystring = qsSplit.shift(); // Necessary because a querystring may contain multiple question marks\n\n  var querystring = qsSplit.join('?');\n\n  if (!querystring) {\n    querystring = initialQsParams;\n  } else {\n    // Whether this is the first time the link has been decorated\n    var initialDecoration = true;\n    var qsFields = querystring.split('&');\n\n    for (var i = 0; i < qsFields.length; i++) {\n      if (qsFields[i].substr(0, name.length + 1) === name + '=') {\n        initialDecoration = false;\n        qsFields[i] = initialQsParams;\n        querystring = qsFields.join('&');\n        break;\n      }\n    }\n\n    if (initialDecoration) {\n      querystring = initialQsParams + '&' + querystring;\n    }\n  }\n\n  hashSplit[0] = beforeQuerystring + '?' + querystring;\n  return hashSplit.join('#');\n}\n/**\n * Attempt to get a value from localStorage\n *\n * @param string - key\n * @return string The value obtained from localStorage, or\n *                undefined if localStorage is inaccessible\n */\n\n\nfunction attemptGetLocalStorage(key) {\n  try {\n    var localStorageAlias = window.localStorage,\n        exp = localStorageAlias.getItem(key + '.expires');\n\n    if (exp === null || +exp > Date.now()) {\n      return localStorageAlias.getItem(key);\n    } else {\n      localStorageAlias.removeItem(key);\n      localStorageAlias.removeItem(key + '.expires');\n    }\n\n    return undefined;\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Attempt to write a value to localStorage\n *\n * @param string - key\n * @param string - value\n * @param number - ttl Time to live in seconds, defaults to 2 years from Date.now()\n * @return boolean Whether the operation succeeded\n */\n\n\nfunction attemptWriteLocalStorage(key, value, ttl) {\n  if (ttl === void 0) {\n    ttl = 63072000;\n  }\n\n  try {\n    var localStorageAlias = window.localStorage,\n        t = Date.now() + ttl * 1000;\n    localStorageAlias.setItem(key + \".expires\", t.toString());\n    localStorageAlias.setItem(key, value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Attempt to delete a value from localStorage\n *\n * @param string - key\n * @return boolean Whether the operation succeeded\n */\n\n\nfunction attemptDeleteLocalStorage(key) {\n  try {\n    var localStorageAlias = window.localStorage;\n    localStorageAlias.removeItem(key);\n    localStorageAlias.removeItem(key + '.expires');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Attempt to get a value from sessionStorage\n *\n * @param string - key\n * @return string The value obtained from sessionStorage, or\n *                undefined if sessionStorage is inaccessible\n */\n\n\nfunction attemptGetSessionStorage(key) {\n  try {\n    return window.sessionStorage.getItem(key);\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\n * Attempt to write a value to sessionStorage\n *\n * @param string - key\n * @param string - value\n * @return boolean Whether the operation succeeded\n */\n\n\nfunction attemptWriteSessionStorage(key, value) {\n  try {\n    window.sessionStorage.setItem(key, value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Finds the root domain\n */\n\n\nfunction findRootDomain(sameSite, secure) {\n  var windowLocationHostnameAlias = window.location.hostname,\n      cookiePrefix = '_sp_root_domain_test_',\n      cookieName = cookiePrefix + new Date().getTime(),\n      cookieValue = '_test_value_' + new Date().getTime();\n  var split = windowLocationHostnameAlias.split('.');\n  var position = split.length - 1;\n\n  while (position >= 0) {\n    var currentDomain = split.slice(position, split.length).join('.');\n    cookie(cookieName, cookieValue, 0, '/', currentDomain, sameSite, secure);\n\n    if (cookie(cookieName) === cookieValue) {\n      // Clean up created cookie(s)\n      deleteCookie(cookieName, currentDomain, sameSite, secure);\n      var cookieNames = getCookiesWithPrefix(cookiePrefix);\n\n      for (var i = 0; i < cookieNames.length; i++) {\n        deleteCookie(cookieNames[i], currentDomain, sameSite, secure);\n      }\n\n      return currentDomain;\n    }\n\n    position -= 1;\n  } // Cookies cannot be read\n\n\n  return windowLocationHostnameAlias;\n}\n/**\n * Checks whether a value is present within an array\n *\n * @param val - The value to check for\n * @param array - The array to check within\n * @return boolean Whether it exists\n */\n\n\nfunction isValueInArray(val, array) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === val) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Deletes an arbitrary cookie by setting the expiration date to the past\n *\n * @param cookieName - The name of the cookie to delete\n * @param domainName - The domain the cookie is in\n */\n\n\nfunction deleteCookie(cookieName, domainName, sameSite, secure) {\n  cookie(cookieName, '', -1, '/', domainName, sameSite, secure);\n}\n/**\n * Fetches the name of all cookies beginning with a certain prefix\n *\n * @param cookiePrefix - The prefix to check for\n * @return array The cookies that begin with the prefix\n */\n\n\nfunction getCookiesWithPrefix(cookiePrefix) {\n  var cookies = document.cookie.split('; ');\n  var cookieNames = [];\n\n  for (var i = 0; i < cookies.length; i++) {\n    if (cookies[i].substring(0, cookiePrefix.length) === cookiePrefix) {\n      cookieNames.push(cookies[i]);\n    }\n  }\n\n  return cookieNames;\n}\n/**\n * Get and set the cookies associated with the current document in browser\n * This implementation always returns a string, returns the cookie value if only name is specified\n *\n * @param name - The cookie name (required)\n * @param value - The cookie value\n * @param ttl - The cookie Time To Live (seconds)\n * @param path - The cookies path\n * @param domain - The cookies domain\n * @param samesite - The cookies samesite attribute\n * @param secure - Boolean to specify if cookie should be secure\n * @return string The cookies value\n */\n\n\nfunction cookie(name, value, ttl, path, domain, samesite, secure) {\n  if (arguments.length > 1) {\n    return document.cookie = name + '=' + encodeURIComponent(value !== null && value !== void 0 ? value : '') + (ttl ? '; Expires=' + new Date(+new Date() + ttl * 1000).toUTCString() : '') + (path ? '; Path=' + path : '') + (domain ? '; Domain=' + domain : '') + (samesite ? '; SameSite=' + samesite : '') + (secure ? '; Secure' : '');\n  }\n\n  return decodeURIComponent((('; ' + document.cookie).split('; ' + name + '=')[1] || '').split(';')[0]);\n}\n/**\n * Parses an object and returns either the\n * integer or undefined.\n *\n * @param obj - The object to parse\n * @return the result of the parse operation\n */\n\n\nfunction parseAndValidateInt(obj) {\n  var result = parseInt(obj);\n  return isNaN(result) ? undefined : result;\n}\n/**\n * Parses an object and returns either the\n * number or undefined.\n *\n * @param obj - The object to parse\n * @return the result of the parse operation\n */\n\n\nfunction parseAndValidateFloat(obj) {\n  var result = parseFloat(obj);\n  return isNaN(result) ? undefined : result;\n}\n/**\n * Convert a criterion object to a filter function\n *\n * @param object - criterion Either {allowlist: [array of allowable strings]}\n *                             or {denylist: [array of allowable strings]}\n *                             or {filter: function (elt) {return whether to track the element}\n * @param boolean - byClass Whether to allowlist/denylist based on an element's classes (for forms)\n *                        or name attribute (for fields)\n */\n\n\nfunction getFilterByClass(criterion) {\n  // If the criterion argument is not an object, add listeners to all elements\n  if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {\n    return function () {\n      return true;\n    };\n  }\n\n  var inclusive = Object.prototype.hasOwnProperty.call(criterion, 'allowlist');\n  var specifiedClassesSet = getSpecifiedClassesSet(criterion);\n  return getFilter(criterion, function (elt) {\n    return checkClass(elt, specifiedClassesSet) === inclusive;\n  });\n}\n/**\n * Convert a criterion object to a filter function\n *\n * @param object - criterion Either {allowlist: [array of allowable strings]}\n *                             or {denylist: [array of allowable strings]}\n *                             or {filter: function (elt) {return whether to track the element}\n */\n\n\nfunction getFilterByName(criterion) {\n  // If the criterion argument is not an object, add listeners to all elements\n  if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {\n    return function () {\n      return true;\n    };\n  }\n\n  var inclusive = criterion.hasOwnProperty('allowlist');\n  var specifiedClassesSet = getSpecifiedClassesSet(criterion);\n  return getFilter(criterion, function (elt) {\n    return elt.name in specifiedClassesSet === inclusive;\n  });\n}\n/**\n * List the classes of a DOM element without using elt.classList (for compatibility with IE 9)\n */\n\n\nfunction getCssClasses(elt) {\n  return elt.className.match(/\\S+/g) || [];\n}\n/**\n * Check whether an element has at least one class from a given list\n */\n\n\nfunction checkClass(elt, classList) {\n  var classes = getCssClasses(elt);\n\n  for (var _i = 0, classes_1 = classes; _i < classes_1.length; _i++) {\n    var className = classes_1[_i];\n\n    if (classList[className]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getFilter(criterion, fallbackFilter) {\n  if (criterion.hasOwnProperty('filter') && criterion.filter) {\n    return criterion.filter;\n  }\n\n  return fallbackFilter;\n}\n\nfunction getSpecifiedClassesSet(criterion) {\n  // Convert the array of classes to an object of the form {class1: true, class2: true, ...}\n  var specifiedClassesSet = {};\n  var specifiedClasses = criterion.allowlist || criterion.denylist;\n\n  if (specifiedClasses) {\n    if (!Array.isArray(specifiedClasses)) {\n      specifiedClasses = [specifiedClasses];\n    }\n\n    for (var i = 0; i < specifiedClasses.length; i++) {\n      specifiedClassesSet[specifiedClasses[i]] = true;\n    }\n  }\n\n  return specifiedClassesSet;\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Object handling sending events to a collector.\n * Instantiated once per tracker instance.\n *\n * @param id - The Snowplow function name (used to generate the localStorage key)\n * @param sharedSate - Stores reference to the outbound queue so it can unload the page when all queues are empty\n * @param useLocalStorage - Whether to use localStorage at all\n * @param eventMethod - if null will use 'beacon' otherwise can be set to 'post', 'get', or 'beacon' to force.\n * @param postPath - The path where events are to be posted\n * @param bufferSize - How many events to batch in localStorage before sending them all\n * @param maxPostBytes - Maximum combined size in bytes of the event JSONs in a POST request\n * @param useStm - Whether to add timestamp to events\n * @param maxLocalStorageQueueSize - Maximum number of queued events we will attempt to store in local storage\n * @param connectionTimeout - Defines how long to wait before aborting the request\n * @param anonymousTracking - Defines whether to set the SP-Anonymous header for anonymous tracking on GET and POST\n * @returns object OutQueueManager instance\n */\n\n\nfunction OutQueueManager(id, sharedSate, useLocalStorage, eventMethod, postPath, bufferSize, maxPostBytes, useStm, maxLocalStorageQueueSize, connectionTimeout, anonymousTracking) {\n  var executingQueue = false,\n      configCollectorUrl,\n      outQueue = []; //Force to lower case if its a string\n\n  eventMethod = typeof eventMethod === 'string' ? eventMethod.toLowerCase() : eventMethod; // Use the Beacon API if eventMethod is set null, true, or 'beacon'.\n\n  var localStorageAlias = window.localStorage,\n      navigatorAlias = window.navigator,\n      isBeaconRequested = eventMethod === null || eventMethod === true || eventMethod === 'beacon' || eventMethod === 'true',\n      // Fall back to POST or GET for browsers which don't support Beacon API\n  isBeaconAvailable = Boolean(isBeaconRequested && navigatorAlias && navigatorAlias.sendBeacon && !hasWebKitBeaconBug(navigatorAlias.userAgent)),\n      useBeacon = isBeaconAvailable && isBeaconRequested,\n      // Use GET if specified\n  isGetRequested = eventMethod === 'get',\n      // Don't use XhrHttpRequest for browsers which don't support CORS XMLHttpRequests (e.g. IE <= 9)\n  useXhr = Boolean(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),\n      // Use POST if specified\n  usePost = !isGetRequested && useXhr && (eventMethod === 'post' || isBeaconRequested),\n      // Resolve all options and capabilities and decide path\n  path = usePost ? postPath : '/i',\n      // Different queue names for GET and POST since they are stored differently\n  queueName = \"snowplowOutQueue_\" + id + \"_\" + (usePost ? 'post2' : 'get'); // Get buffer size or set 1 if unable to buffer\n\n  bufferSize = localStorageAccessible() && useLocalStorage && usePost && bufferSize || 1;\n\n  if (useLocalStorage) {\n    // Catch any JSON parse errors or localStorage that might be thrown\n    try {\n      var localStorageQueue = localStorageAlias.getItem(queueName);\n      outQueue = localStorageQueue ? JSON.parse(localStorageQueue) : [];\n    } catch (e) {}\n  } // Initialize to and empty array if we didn't get anything out of localStorage\n\n\n  if (!Array.isArray(outQueue)) {\n    outQueue = [];\n  } // Used by pageUnloadGuard\n\n\n  sharedSate.outQueues.push(outQueue);\n\n  if (useXhr && bufferSize > 1) {\n    sharedSate.bufferFlushers.push(function (sync) {\n      if (!executingQueue) {\n        _executeQueue(sync);\n      }\n    });\n  }\n  /*\n   * Convert a dictionary to a querystring\n   * The context field is the last in the querystring\n   */\n\n\n  function getQuerystring(request) {\n    var querystring = '?',\n        lowPriorityKeys = {\n      co: true,\n      cx: true\n    },\n        firstPair = true;\n\n    for (var key in request) {\n      if (request.hasOwnProperty(key) && !lowPriorityKeys.hasOwnProperty(key)) {\n        if (!firstPair) {\n          querystring += '&';\n        } else {\n          firstPair = false;\n        }\n\n        querystring += encodeURIComponent(key) + '=' + encodeURIComponent(request[key]);\n      }\n    }\n\n    for (var contextKey in lowPriorityKeys) {\n      if (request.hasOwnProperty(contextKey) && lowPriorityKeys.hasOwnProperty(contextKey)) {\n        querystring += '&' + contextKey + '=' + encodeURIComponent(request[contextKey]);\n      }\n    }\n\n    return querystring;\n  }\n  /*\n   * Convert numeric fields to strings to match payload_data schema\n   */\n\n\n  function getBody(request) {\n    var cleanedRequest = Object.keys(request).map(function (k) {\n      return [k, request[k]];\n    }).reduce(function (acc, _a) {\n      var key = _a[0],\n          value = _a[1];\n      acc[key] = value.toString();\n      return acc;\n    }, {});\n    return {\n      evt: cleanedRequest,\n      bytes: getUTF8Length(JSON.stringify(cleanedRequest))\n    };\n  }\n  /**\n   * Count the number of bytes a string will occupy when UTF-8 encoded\n   * Taken from http://stackoverflow.com/questions/2848462/count-bytes-in-textarea-using-javascript/\n   *\n   * @param string - s\n   * @return number Length of s in bytes when UTF-8 encoded\n   */\n\n\n  function getUTF8Length(s) {\n    var len = 0;\n\n    for (var i = 0; i < s.length; i++) {\n      var code = s.charCodeAt(i);\n\n      if (code <= 0x7f) {\n        len += 1;\n      } else if (code <= 0x7ff) {\n        len += 2;\n      } else if (code >= 0xd800 && code <= 0xdfff) {\n        // Surrogate pair: These take 4 bytes in UTF-8 and 2 chars in UCS-2\n        // (Assume next char is the other [valid] half and just skip it)\n        len += 4;\n        i++;\n      } else if (code < 0xffff) {\n        len += 3;\n      } else {\n        len += 4;\n      }\n    }\n\n    return len;\n  }\n\n  var postable = function postable(queue) {\n    return typeof queue[0] === 'object';\n  };\n  /*\n   * Queue for submission to the collector and start processing queue\n   */\n\n\n  function enqueueRequest(request, url) {\n    configCollectorUrl = url + path;\n\n    if (usePost) {\n      var body = getBody(request);\n\n      if (body.bytes >= maxPostBytes) {\n        LOG.warn('Event (' + body.bytes + 'B) too big, max is ' + maxPostBytes);\n        var xhr = initializeXMLHttpRequest(configCollectorUrl, true, false);\n        xhr.send(encloseInPayloadDataEnvelope(attachStmToEvent([body.evt])));\n        return;\n      } else {\n        outQueue.push(body);\n      }\n    } else {\n      outQueue.push(getQuerystring(request));\n    }\n\n    var savedToLocalStorage = false;\n\n    if (useLocalStorage) {\n      savedToLocalStorage = attemptWriteLocalStorage(queueName, JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize)));\n    } // If we're not processing the queue, we'll start.\n\n\n    if (!executingQueue && (!savedToLocalStorage || outQueue.length >= bufferSize)) {\n      _executeQueue();\n    }\n  }\n  /*\n   * Run through the queue of requests, sending them one at a time.\n   * Stops processing when we run out of queued requests, or we get an error.\n   */\n\n\n  function _executeQueue(sync) {\n    if (sync === void 0) {\n      sync = false;\n    } // Failsafe in case there is some way for a bad value like \"null\" to end up in the outQueue\n\n\n    while (outQueue.length && typeof outQueue[0] !== 'string' && typeof outQueue[0] !== 'object') {\n      outQueue.shift();\n    }\n\n    if (outQueue.length < 1) {\n      executingQueue = false;\n      return;\n    } // Let's check that we have a URL\n\n\n    if (!isString(configCollectorUrl)) {\n      throw 'No collector configured';\n    }\n\n    executingQueue = true;\n\n    if (useXhr) {\n      // Keep track of number of events to delete from queue\n      var chooseHowManyToSend = function chooseHowManyToSend(queue) {\n        var numberToSend = 0,\n            byteCount = 0;\n\n        while (numberToSend < queue.length) {\n          byteCount += queue[numberToSend].bytes;\n\n          if (byteCount >= maxPostBytes) {\n            break;\n          } else {\n            numberToSend += 1;\n          }\n        }\n\n        return numberToSend;\n      };\n\n      var url = void 0,\n          xhr_1,\n          numberToSend_1;\n\n      if (postable(outQueue)) {\n        url = configCollectorUrl;\n        xhr_1 = initializeXMLHttpRequest(url, true, sync);\n        numberToSend_1 = chooseHowManyToSend(outQueue);\n      } else {\n        url = createGetUrl(outQueue[0]);\n        xhr_1 = initializeXMLHttpRequest(url, false, sync);\n        numberToSend_1 = 1;\n      } // Time out POST requests after connectionTimeout\n\n\n      var xhrTimeout_1 = setTimeout(function () {\n        xhr_1.abort();\n        executingQueue = false;\n      }, connectionTimeout); // The events (`numberToSend` of them), have been sent, so we remove them from the outQueue\n      // We also call executeQueue() again, to let executeQueue() check if we should keep running through the queue\n\n      var onPostSuccess_1 = function onPostSuccess_1(numberToSend) {\n        for (var deleteCount = 0; deleteCount < numberToSend; deleteCount++) {\n          outQueue.shift();\n        }\n\n        if (useLocalStorage) {\n          attemptWriteLocalStorage(queueName, JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize)));\n        }\n\n        _executeQueue();\n      };\n\n      xhr_1.onreadystatechange = function () {\n        if (xhr_1.readyState === 4 && xhr_1.status >= 200 && xhr_1.status < 400) {\n          clearTimeout(xhrTimeout_1);\n          onPostSuccess_1(numberToSend_1);\n        } else if (xhr_1.readyState === 4 && xhr_1.status >= 400) {\n          clearTimeout(xhrTimeout_1);\n          executingQueue = false;\n        }\n      };\n\n      if (!postable(outQueue)) {\n        // If not postable then it's a GET so just send it\n        xhr_1.send();\n      } else {\n        var batch = outQueue.slice(0, numberToSend_1);\n\n        if (batch.length > 0) {\n          var beaconStatus = false;\n          var eventBatch = batch.map(function (x) {\n            return x.evt;\n          });\n\n          if (useBeacon) {\n            var blob = new Blob([encloseInPayloadDataEnvelope(attachStmToEvent(eventBatch))], {\n              type: 'application/json'\n            });\n\n            try {\n              beaconStatus = navigator.sendBeacon(url, blob);\n            } catch (error) {\n              beaconStatus = false;\n            }\n          } // When beaconStatus is true, we can't _guarantee_ that it was successful (beacon queues asynchronously)\n          // but the browser has taken it out of our hands, so we want to flush the queue assuming it will do its job\n\n\n          if (beaconStatus === true) {\n            onPostSuccess_1(numberToSend_1);\n          } else {\n            xhr_1.send(encloseInPayloadDataEnvelope(attachStmToEvent(eventBatch)));\n          }\n        }\n      }\n    } else if (!anonymousTracking && !postable(outQueue)) {\n      // We can't send with this technique if anonymous tracking is on as we can't attach the header\n      var image = new Image(1, 1),\n          loading_1 = true;\n\n      image.onload = function () {\n        if (!loading_1) return;\n        loading_1 = false;\n        outQueue.shift();\n\n        if (useLocalStorage) {\n          attemptWriteLocalStorage(queueName, JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize)));\n        }\n\n        _executeQueue();\n      };\n\n      image.onerror = function () {\n        if (!loading_1) return;\n        loading_1 = false;\n        executingQueue = false;\n      };\n\n      image.src = createGetUrl(outQueue[0]);\n      setTimeout(function () {\n        if (loading_1 && executingQueue) {\n          loading_1 = false;\n\n          _executeQueue();\n        }\n      }, connectionTimeout);\n    } else {\n      executingQueue = false;\n    }\n  }\n  /**\n   * Open an XMLHttpRequest for a given endpoint with the correct credentials and header\n   *\n   * @param string - url The destination URL\n   * @return object The XMLHttpRequest\n   */\n\n\n  function initializeXMLHttpRequest(url, post, sync) {\n    var xhr = new XMLHttpRequest();\n\n    if (post) {\n      xhr.open('POST', url, !sync);\n      xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');\n    } else {\n      xhr.open('GET', url, !sync);\n    }\n\n    xhr.withCredentials = true;\n\n    if (anonymousTracking) {\n      xhr.setRequestHeader('SP-Anonymous', '*');\n    }\n\n    return xhr;\n  }\n  /**\n   * Enclose an array of events in a self-describing payload_data JSON string\n   *\n   * @param array - events Batch of events\n   * @return string payload_data self-describing JSON\n   */\n\n\n  function encloseInPayloadDataEnvelope(events) {\n    return JSON.stringify({\n      schema: 'iglu:com.snowplowanalytics.snowplow/payload_data/jsonschema/1-0-4',\n      data: events\n    });\n  }\n  /**\n   * Attaches the STM field to outbound POST events.\n   *\n   * @param events - the events to attach the STM to\n   */\n\n\n  function attachStmToEvent(events) {\n    var stm = new Date().getTime().toString();\n\n    for (var i = 0; i < events.length; i++) {\n      events[i]['stm'] = stm;\n    }\n\n    return events;\n  }\n  /**\n   * Creates the full URL for sending the GET request. Will append `stm` if enabled\n   *\n   * @param nextRequest - the query string of the next request\n   */\n\n\n  function createGetUrl(nextRequest) {\n    if (useStm) {\n      return configCollectorUrl + nextRequest.replace('?', '?stm=' + new Date().getTime() + '&');\n    }\n\n    return configCollectorUrl + nextRequest;\n  }\n\n  return {\n    enqueueRequest: enqueueRequest,\n    executeQueue: function executeQueue() {\n      if (!executingQueue) {\n        _executeQueue();\n      }\n    },\n    setUseLocalStorage: function setUseLocalStorage(localStorage) {\n      useLocalStorage = localStorage;\n    },\n    setAnonymousTracking: function setAnonymousTracking(anonymous) {\n      anonymousTracking = anonymous;\n    },\n    setCollectorUrl: function setCollectorUrl(url) {\n      configCollectorUrl = url + path;\n    },\n    setBufferSize: function setBufferSize(newBufferSize) {\n      bufferSize = newBufferSize;\n    }\n  };\n\n  function hasWebKitBeaconBug(useragent) {\n    return isIosVersionLessThanOrEqualTo(13, useragent) || isMacosxVersionLessThanOrEqualTo(10, 15, useragent) && isSafari(useragent);\n\n    function isIosVersionLessThanOrEqualTo(major, useragent) {\n      var match = useragent.match('(iP.+; CPU .*OS (d+)[_d]*.*) AppleWebKit/');\n\n      if (match && match.length) {\n        return parseInt(match[0]) <= major;\n      }\n\n      return false;\n    }\n\n    function isMacosxVersionLessThanOrEqualTo(major, minor, useragent) {\n      var match = useragent.match('(Macintosh;.*Mac OS X (d+)_(d+)[_d]*.*) AppleWebKit/');\n\n      if (match && match.length) {\n        return parseInt(match[0]) <= major || parseInt(match[0]) === major && parseInt(match[1]) <= minor;\n      }\n\n      return false;\n    }\n\n    function isSafari(useragent) {\n      return useragent.match('Version/.* Safari/') && !isChromiumBased(useragent);\n    }\n\n    function isChromiumBased(useragent) {\n      return useragent.match('Chrom(e|ium)');\n    }\n  }\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Extract parameter from URL\n */\n\n\nfunction getParameter(url, name) {\n  // scheme : // [username [: password] @] hostname [: port] [/ [path] [? query] [# fragment]]\n  var e = new RegExp('^(?:https?|ftp)(?::/*(?:[^?]+))([?][^#]+)'),\n      matches = e.exec(url);\n\n  if (matches && (matches === null || matches === void 0 ? void 0 : matches.length) > 1) {\n    return fromQuerystring(name, matches[1]);\n  }\n\n  return null;\n}\n/*\n * Fix-up URL when page rendered from search engine cache or translated page.\n */\n\n\nfunction fixupUrl(hostName, href, referrer) {\n  var _a;\n\n  if (hostName === 'translate.googleusercontent.com') {\n    // Google\n    if (referrer === '') {\n      referrer = href;\n    }\n\n    href = (_a = getParameter(href, 'u')) !== null && _a !== void 0 ? _a : '';\n    hostName = getHostName(href);\n  } else if (hostName === 'cc.bingj.com' || // Bing & Yahoo\n  hostName === 'webcache.googleusercontent.com' // Google\n  ) {\n      href = document.links[0].href;\n      hostName = getHostName(href);\n    }\n\n  return [hostName, href, referrer];\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * The Snowplow Tracker\n *\n * @param trackerId - The unique identifier of the tracker\n * @param namespace - The namespace of the tracker object\n * @param version - The current version of the JavaScript Tracker\n * @param endpoint - The collector endpoint to send events to, with or without protocol\n * @param sharedState - An object containing state which is shared across tracker instances\n * @param trackerConfiguration - Dictionary of configuration options\n */\n\n\nfunction Tracker(trackerId, namespace, version, endpoint, sharedState, trackerConfiguration) {\n  var _a;\n\n  if (trackerConfiguration === void 0) {\n    trackerConfiguration = {};\n  }\n\n  var newTracker = function newTracker(trackerId, namespace, version, endpoint, state, trackerConfiguration) {\n    /************************************************************\n     * Private members\n     ************************************************************/\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u; //use POST if eventMethod isn't present on the newTrackerConfiguration\n\n\n    trackerConfiguration.eventMethod = (_a = trackerConfiguration.eventMethod) !== null && _a !== void 0 ? _a : 'post';\n\n    var getStateStorageStrategy = function getStateStorageStrategy(config) {\n      var _a;\n\n      return (_a = config.stateStorageStrategy) !== null && _a !== void 0 ? _a : 'cookieAndLocalStorage';\n    },\n        getAnonymousSessionTracking = function getAnonymousSessionTracking(config) {\n      var _a, _b;\n\n      if (typeof config.anonymousTracking === 'boolean') {\n        return false;\n      }\n\n      return (_b = ((_a = config.anonymousTracking) === null || _a === void 0 ? void 0 : _a.withSessionTracking) === true) !== null && _b !== void 0 ? _b : false;\n    },\n        getAnonymousServerTracking = function getAnonymousServerTracking(config) {\n      var _a, _b;\n\n      if (typeof config.anonymousTracking === 'boolean') {\n        return false;\n      }\n\n      return (_b = ((_a = config.anonymousTracking) === null || _a === void 0 ? void 0 : _a.withServerAnonymisation) === true) !== null && _b !== void 0 ? _b : false;\n    },\n        getAnonymousTracking = function getAnonymousTracking(config) {\n      return !!config.anonymousTracking;\n    }; // Get all injected plugins\n\n\n    trackerConfiguration.plugins = (_b = trackerConfiguration.plugins) !== null && _b !== void 0 ? _b : [];\n\n    if ((_d = (_c = trackerConfiguration === null || trackerConfiguration === void 0 ? void 0 : trackerConfiguration.contexts) === null || _c === void 0 ? void 0 : _c.webPage) !== null && _d !== void 0 ? _d : true) {\n      trackerConfiguration.plugins.push(getWebPagePlugin()); // Defaults to including the Web Page context\n    }\n\n    var // Tracker core\n    core = trackerCore({\n      base64: trackerConfiguration.encodeBase64,\n      corePlugins: trackerConfiguration.plugins,\n      callback: function callback(payloadBuilder) {\n        addBrowserData(payloadBuilder);\n        sendRequest(payloadBuilder);\n      }\n    }),\n        // Aliases\n    browserLanguage = navigator.userLanguage || navigator.language,\n        documentCharset = document.characterSet || document.charset,\n        // Current URL and Referrer URL\n    locationArray = fixupUrl(window.location.hostname, window.location.href, getReferrer()),\n        domainAlias = fixupDomain(locationArray[0]),\n        locationHrefAlias = locationArray[1],\n        configReferrerUrl = locationArray[2],\n        customReferrer,\n        // Platform defaults to web for this tracker\n    configPlatform = (_e = trackerConfiguration.platform) !== null && _e !== void 0 ? _e : 'web',\n        // Snowplow collector URL\n    configCollectorUrl = asCollectorUrl(endpoint),\n        // Custom path for post requests (to get around adblockers)\n    configPostPath = (_f = trackerConfiguration.postPath) !== null && _f !== void 0 ? _f : '/com.snowplowanalytics.snowplow/tp2',\n        // Site ID\n    configTrackerSiteId = (_g = trackerConfiguration.appId) !== null && _g !== void 0 ? _g : '',\n        // Document URL\n    configCustomUrl,\n        // Document title\n    lastDocumentTitle = document.title,\n        // Custom title\n    lastConfigTitle,\n        // Controls whether activity tracking page ping event timers are reset on page view events\n    resetActivityTrackingOnPageView = (_h = trackerConfiguration.resetActivityTrackingOnPageView) !== null && _h !== void 0 ? _h : true,\n        // Disallow hash tags in URL. TODO: Should this be set to true by default?\n    configDiscardHashTag,\n        // Disallow brace in URL.\n    configDiscardBrace,\n        // First-party cookie name prefix\n    configCookieNamePrefix = (_j = trackerConfiguration.cookieName) !== null && _j !== void 0 ? _j : '_sp_',\n        // First-party cookie domain\n    // User agent defaults to origin hostname\n    configCookieDomain = (_k = trackerConfiguration.cookieDomain) !== null && _k !== void 0 ? _k : undefined,\n        // First-party cookie path\n    // Default is user agent defined.\n    configCookiePath = '/',\n        // First-party cookie samesite attribute\n    configCookieSameSite = (_l = trackerConfiguration.cookieSameSite) !== null && _l !== void 0 ? _l : 'None',\n        // First-party cookie secure attribute\n    configCookieSecure = (_m = trackerConfiguration.cookieSecure) !== null && _m !== void 0 ? _m : true,\n        // Do Not Track browser feature\n    dnt = navigator.doNotTrack || navigator.msDoNotTrack || window.doNotTrack,\n        // Do Not Track\n    configDoNotTrack = typeof trackerConfiguration.respectDoNotTrack !== 'undefined' ? trackerConfiguration.respectDoNotTrack && (dnt === 'yes' || dnt === '1') : false,\n        // Opt out of cookie tracking\n    configOptOutCookie,\n        // Life of the visitor cookie (in seconds)\n    configVisitorCookieTimeout = (_o = trackerConfiguration.cookieLifetime) !== null && _o !== void 0 ? _o : 63072000,\n        // 2 years\n    // Life of the session cookie (in seconds)\n    configSessionCookieTimeout = (_p = trackerConfiguration.sessionCookieTimeout) !== null && _p !== void 0 ? _p : 1800,\n        // 30 minutes\n    // Allows tracking user session (using cookies or local storage), can only be used with anonymousTracking\n    configAnonymousSessionTracking = getAnonymousSessionTracking(trackerConfiguration),\n        // Will send a header to server to prevent returning cookie and capturing IP\n    configAnonymousServerTracking = getAnonymousServerTracking(trackerConfiguration),\n        // Sets tracker to work in anonymous mode without accessing client storage\n    configAnonymousTracking = getAnonymousTracking(trackerConfiguration),\n        // Strategy defining how to store the state: cookie, localStorage, cookieAndLocalStorage or none\n    configStateStorageStrategy = getStateStorageStrategy(trackerConfiguration),\n        // Last activity timestamp\n    lastActivityTime,\n        // The last time an event was fired on the page - used to invalidate session if cookies are disabled\n    lastEventTime = new Date().getTime(),\n        // How are we scrolling?\n    minXOffset,\n        maxXOffset,\n        minYOffset,\n        maxYOffset,\n        // Domain hash value\n    domainHash,\n        // Domain unique user ID\n    domainUserId,\n        // ID for the current session\n    memorizedSessionId,\n        // Index for the current session - kept in memory in case cookies are disabled\n    memorizedVisitCount = 1,\n        // Business-defined unique user ID\n    businessUserId,\n        // Manager for local storage queue\n    outQueue = OutQueueManager(trackerId, state, configStateStorageStrategy == 'localStorage' || configStateStorageStrategy == 'cookieAndLocalStorage', trackerConfiguration.eventMethod, configPostPath, (_q = trackerConfiguration.bufferSize) !== null && _q !== void 0 ? _q : 1, (_r = trackerConfiguration.maxPostBytes) !== null && _r !== void 0 ? _r : 40000, (_s = trackerConfiguration.useStm) !== null && _s !== void 0 ? _s : true, (_t = trackerConfiguration.maxLocalStorageQueueSize) !== null && _t !== void 0 ? _t : 1000, (_u = trackerConfiguration.connectionTimeout) !== null && _u !== void 0 ? _u : 5000, configAnonymousServerTracking),\n        // Whether pageViewId should be regenerated after each trackPageView. Affect web_page context\n    _preservePageViewId = false,\n        // Whether first trackPageView was fired and pageViewId should not be changed anymore until reload\n    pageViewSent = false,\n        // Activity tracking config for callback and pacge ping variants\n    activityTrackingConfig = {\n      enabled: false,\n      installed: false,\n      configurations: {}\n    };\n\n    if (trackerConfiguration.hasOwnProperty('discoverRootDomain') && trackerConfiguration.discoverRootDomain) {\n      configCookieDomain = findRootDomain(configCookieSameSite, configCookieSecure);\n    } // Set up unchanging name-value pairs\n\n\n    core.setTrackerVersion(version);\n    core.setTrackerNamespace(namespace);\n    core.setAppId(configTrackerSiteId);\n    core.setPlatform(configPlatform);\n    core.addPayloadPair('cookie', navigator.cookieEnabled ? '1' : '0');\n    core.addPayloadPair('cs', documentCharset);\n    core.addPayloadPair('lang', browserLanguage);\n    core.addPayloadPair('res', screen.width + 'x' + screen.height);\n    core.addPayloadPair('cd', screen.colorDepth);\n    /*\n     * Initialize tracker\n     */\n\n    updateDomainHash();\n    initializeIdsAndCookies();\n\n    if (trackerConfiguration.crossDomainLinker) {\n      decorateLinks(trackerConfiguration.crossDomainLinker);\n    }\n    /**\n     * Recalculate the domain, URL, and referrer\n     */\n\n\n    function refreshUrl() {\n      locationArray = fixupUrl(window.location.hostname, window.location.href, getReferrer()); // If this is a single-page app and the page URL has changed, then:\n      //   - if the new URL's querystring contains a \"refer(r)er\" parameter, use it as the referrer\n      //   - otherwise use the old URL as the referer\n\n      if (locationArray[1] !== locationHrefAlias) {\n        configReferrerUrl = getReferrer(locationHrefAlias);\n      }\n\n      domainAlias = fixupDomain(locationArray[0]);\n      locationHrefAlias = locationArray[1];\n    }\n    /**\n     * Decorate the querystring of a single link\n     *\n     * @param event - e The event targeting the link\n     */\n\n\n    function linkDecorationHandler(evt) {\n      var timestamp = new Date().getTime();\n      var elt = evt.target;\n\n      if (elt === null || elt === void 0 ? void 0 : elt.href) {\n        elt.href = decorateQuerystring(elt.href, '_sp', domainUserId + '.' + timestamp);\n      }\n    }\n    /**\n     * Enable querystring decoration for links pasing a filter\n     * Whenever such a link is clicked on or navigated to via the keyboard,\n     * add \"_sp={{duid}}.{{timestamp}}\" to its querystring\n     *\n     * @param crossDomainLinker - Function used to determine which links to decorate\n     */\n\n\n    function decorateLinks(crossDomainLinker) {\n      for (var i = 0; i < document.links.length; i++) {\n        var elt = document.links[i];\n\n        if (!elt.spDecorationEnabled && crossDomainLinker(elt)) {\n          addEventListener(elt, 'click', linkDecorationHandler, true);\n          addEventListener(elt, 'mousedown', linkDecorationHandler, true); // Don't add event listeners more than once\n\n          elt.spDecorationEnabled = true;\n        }\n      }\n    }\n    /*\n     * Removes hash tag from the URL\n     *\n     * URLs are purified before being recorded in the cookie,\n     * or before being sent as GET parameters\n     */\n\n\n    function purify(url) {\n      var targetPattern;\n\n      if (configDiscardHashTag) {\n        targetPattern = new RegExp('#.*');\n        url = url.replace(targetPattern, '');\n      }\n\n      if (configDiscardBrace) {\n        targetPattern = new RegExp('[{}]', 'g');\n        url = url.replace(targetPattern, '');\n      }\n\n      return url;\n    }\n    /*\n     * Extract scheme/protocol from URL\n     */\n\n\n    function getProtocolScheme(url) {\n      var e = new RegExp('^([a-z]+):'),\n          matches = e.exec(url);\n      return matches ? matches[1] : null;\n    }\n    /*\n     * Resolve relative reference\n     *\n     * Note: not as described in rfc3986 section 5.2\n     */\n\n\n    function resolveRelativeReference(baseUrl, url) {\n      var protocol = getProtocolScheme(url),\n          i;\n\n      if (protocol) {\n        return url;\n      }\n\n      if (url.slice(0, 1) === '/') {\n        return getProtocolScheme(baseUrl) + '://' + getHostName(baseUrl) + url;\n      }\n\n      baseUrl = purify(baseUrl);\n\n      if ((i = baseUrl.indexOf('?')) >= 0) {\n        baseUrl = baseUrl.slice(0, i);\n      }\n\n      if ((i = baseUrl.lastIndexOf('/')) !== baseUrl.length - 1) {\n        baseUrl = baseUrl.slice(0, i + 1);\n      }\n\n      return baseUrl + url;\n    }\n    /*\n     * Send request\n     */\n\n\n    function sendRequest(request) {\n      // Set to true if Opt-out cookie is defined\n      var toOptoutByCookie;\n\n      if (configOptOutCookie) {\n        toOptoutByCookie = !!cookie(configOptOutCookie);\n      } else {\n        toOptoutByCookie = false;\n      }\n\n      if (!(configDoNotTrack || toOptoutByCookie)) {\n        outQueue.enqueueRequest(request.build(), configCollectorUrl);\n      }\n    }\n    /*\n     * Get cookie name with prefix and domain hash\n     */\n\n\n    function getSnowplowCookieName(baseName) {\n      return configCookieNamePrefix + baseName + '.' + domainHash;\n    }\n    /*\n     * Cookie getter.\n     */\n\n\n    function getSnowplowCookieValue(cookieName) {\n      var fullName = getSnowplowCookieName(cookieName);\n\n      if (configStateStorageStrategy == 'localStorage') {\n        return attemptGetLocalStorage(fullName);\n      } else if (configStateStorageStrategy == 'cookie' || configStateStorageStrategy == 'cookieAndLocalStorage') {\n        return cookie(fullName);\n      }\n\n      return undefined;\n    }\n    /*\n     * Update domain hash\n     */\n\n\n    function updateDomainHash() {\n      refreshUrl();\n      domainHash = hash((configCookieDomain || domainAlias) + (configCookiePath || '/')).slice(0, 4); // 4 hexits = 16 bits\n    }\n    /*\n     * Process all \"activity\" events.\n     * For performance, this function must have low overhead.\n     */\n\n\n    function activityHandler() {\n      var now = new Date();\n      lastActivityTime = now.getTime();\n    }\n    /*\n     * Process all \"scroll\" events.\n     */\n\n\n    function scrollHandler() {\n      updateMaxScrolls();\n      activityHandler();\n    }\n    /*\n     * Returns [pageXOffset, pageYOffset]\n     */\n\n\n    function getPageOffsets() {\n      var documentElement = document.documentElement;\n\n      if (documentElement) {\n        return [documentElement.scrollLeft || window.pageXOffset, documentElement.scrollTop || window.pageYOffset];\n      }\n\n      return [0, 0];\n    }\n    /*\n     * Quick initialization/reset of max scroll levels\n     */\n\n\n    function resetMaxScrolls() {\n      var offsets = getPageOffsets();\n      var x = offsets[0];\n      minXOffset = x;\n      maxXOffset = x;\n      var y = offsets[1];\n      minYOffset = y;\n      maxYOffset = y;\n    }\n    /*\n     * Check the max scroll levels, updating as necessary\n     */\n\n\n    function updateMaxScrolls() {\n      var offsets = getPageOffsets();\n      var x = offsets[0];\n\n      if (x < minXOffset) {\n        minXOffset = x;\n      } else if (x > maxXOffset) {\n        maxXOffset = x;\n      }\n\n      var y = offsets[1];\n\n      if (y < minYOffset) {\n        minYOffset = y;\n      } else if (y > maxYOffset) {\n        maxYOffset = y;\n      }\n    }\n    /*\n     * Prevents offsets from being decimal or NaN\n     * See https://github.com/snowplow/snowplow-javascript-tracker/issues/324\n     */\n\n\n    function cleanOffset(offset) {\n      return Math.round(offset);\n    }\n    /*\n     * Sets or renews the session cookie\n     */\n\n\n    function setSessionCookie() {\n      var cookieName = getSnowplowCookieName('ses');\n      var cookieValue = '*';\n      setCookie(cookieName, cookieValue, configSessionCookieTimeout);\n    }\n    /*\n     * Sets the Visitor ID cookie: either the first time loadDomainUserIdCookie is called\n     * or when there is a new visit or a new page view\n     */\n\n\n    function setDomainUserIdCookie(domainUserId, createTs, visitCount, nowTs, lastVisitTs, sessionId) {\n      var cookieName = getSnowplowCookieName('id');\n      var cookieValue = domainUserId + '.' + createTs + '.' + visitCount + '.' + nowTs + '.' + lastVisitTs + '.' + sessionId;\n      setCookie(cookieName, cookieValue, configVisitorCookieTimeout);\n    }\n    /*\n     * no-op if anonymousTracking enabled, will still set cookies if anonymousSessionTracking is enabled\n     * Sets a cookie based on the storage strategy:\n     * - if 'localStorage': attemps to write to local storage\n     * - if 'cookie' or 'cookieAndLocalStorage': writes to cookies\n     * - otherwise: no-op\n     */\n\n\n    function setCookie(name, value, timeout) {\n      if (configAnonymousTracking && !configAnonymousSessionTracking) {\n        return;\n      }\n\n      if (configStateStorageStrategy == 'localStorage') {\n        attemptWriteLocalStorage(name, value, timeout);\n      } else if (configStateStorageStrategy == 'cookie' || configStateStorageStrategy == 'cookieAndLocalStorage') {\n        cookie(name, value, timeout, configCookiePath, configCookieDomain, configCookieSameSite, configCookieSecure);\n      }\n    }\n    /**\n     * Clears all cookie and local storage for id and ses values\n     */\n\n\n    function clearUserDataAndCookies(configuration) {\n      var idname = getSnowplowCookieName('id');\n      var sesname = getSnowplowCookieName('ses');\n      attemptDeleteLocalStorage(idname);\n      attemptDeleteLocalStorage(sesname);\n      deleteCookie(idname, configCookieDomain, configCookieSameSite, configCookieSecure);\n      deleteCookie(sesname, configCookieDomain, configCookieSameSite, configCookieSecure);\n\n      if (!(configuration === null || configuration === void 0 ? void 0 : configuration.preserveSession)) {\n        memorizedSessionId = v4();\n        memorizedVisitCount = 0;\n      }\n\n      if (!(configuration === null || configuration === void 0 ? void 0 : configuration.preserveUser)) {\n        domainUserId = v4();\n        businessUserId = null;\n      }\n    }\n    /**\n     * Toggle Anaonymous Tracking\n     */\n\n\n    function toggleAnonymousTracking(configuration) {\n      if (configuration && configuration.stateStorageStrategy) {\n        trackerConfiguration.stateStorageStrategy = configuration.stateStorageStrategy;\n        configStateStorageStrategy = getStateStorageStrategy(trackerConfiguration);\n      }\n\n      configAnonymousTracking = getAnonymousTracking(trackerConfiguration);\n      configAnonymousSessionTracking = getAnonymousSessionTracking(trackerConfiguration);\n      configAnonymousServerTracking = getAnonymousServerTracking(trackerConfiguration);\n      outQueue.setUseLocalStorage(configStateStorageStrategy == 'localStorage' || configStateStorageStrategy == 'cookieAndLocalStorage');\n      outQueue.setAnonymousTracking(configAnonymousServerTracking);\n    }\n    /*\n     * Load the domain user ID and the session ID\n     * Set the cookies (if cookies are enabled)\n     */\n\n\n    function initializeIdsAndCookies() {\n      if (configAnonymousTracking && !configAnonymousSessionTracking) {\n        return;\n      }\n\n      var sesCookieSet = configStateStorageStrategy != 'none' && !!getSnowplowCookieValue('ses');\n      var idCookieComponents = loadDomainUserIdCookie();\n\n      if (idCookieComponents[1]) {\n        domainUserId = idCookieComponents[1];\n      } else if (!configAnonymousTracking) {\n        domainUserId = v4();\n        idCookieComponents[1] = domainUserId;\n      } else {\n        domainUserId = '';\n        idCookieComponents[1] = domainUserId;\n      }\n\n      memorizedSessionId = idCookieComponents[6];\n\n      if (!sesCookieSet) {\n        // Increment the session ID\n        idCookieComponents[3]++; // Create a new sessionId\n\n        memorizedSessionId = v4();\n        idCookieComponents[6] = memorizedSessionId; // Set lastVisitTs to currentVisitTs\n\n        idCookieComponents[5] = idCookieComponents[4];\n      }\n\n      if (configStateStorageStrategy != 'none') {\n        setSessionCookie(); // Update currentVisitTs\n\n        idCookieComponents[4] = Math.round(new Date().getTime() / 1000);\n        idCookieComponents.shift();\n        setDomainUserIdCookie.apply(null, idCookieComponents); // TODO: Remove any\n      }\n    }\n    /*\n     * Load visitor ID cookie\n     */\n\n\n    function loadDomainUserIdCookie() {\n      if (configStateStorageStrategy == 'none') {\n        return [];\n      }\n\n      var now = new Date(),\n          nowTs = Math.round(now.getTime() / 1000),\n          id = getSnowplowCookieValue('id'),\n          tmpContainer;\n\n      if (id) {\n        tmpContainer = id.split('.'); // cookies enabled\n\n        tmpContainer.unshift('0');\n      } else {\n        tmpContainer = [// cookies disabled\n        '1', // Domain user ID\n        domainUserId, // Creation timestamp - seconds since Unix epoch\n        nowTs, // visitCount - 0 = no previous visit\n        0, // Current visit timestamp\n        nowTs, // Last visit timestamp - blank meaning no previous visit\n        ''];\n      }\n\n      if (!tmpContainer[6]) {\n        // session id\n        tmpContainer[6] = v4();\n      }\n\n      return tmpContainer;\n    }\n    /*\n     * Attaches common web fields to every request (resolution, url, referrer, etc.)\n     * Also sets the required cookies.\n     */\n\n\n    function addBrowserData(payloadBuilder) {\n      var anonymizeOr = function anonymizeOr(value) {\n        return configAnonymousTracking ? null : value;\n      };\n\n      var anonymizeSessionOr = function anonymizeSessionOr(value) {\n        return configAnonymousSessionTracking ? value : anonymizeOr(value);\n      };\n\n      var nowTs = Math.round(new Date().getTime() / 1000),\n          ses = getSnowplowCookieValue('ses'),\n          id = loadDomainUserIdCookie(),\n          cookiesDisabled = id[0],\n          _domainUserId = id[1],\n          // We could use the global (domainUserId) but this is better etiquette\n      createTs = id[2],\n          visitCount = id[3],\n          currentVisitTs = id[4],\n          lastVisitTs = id[5],\n          sessionIdFromCookie = id[6];\n      var toOptoutByCookie;\n\n      if (configOptOutCookie) {\n        toOptoutByCookie = !!cookie(configOptOutCookie);\n      } else {\n        toOptoutByCookie = false;\n      }\n\n      if (configDoNotTrack || toOptoutByCookie) {\n        clearUserDataAndCookies();\n        return;\n      } // If cookies are enabled, base visit count and session ID on the cookies\n\n\n      if (cookiesDisabled === '0') {\n        memorizedSessionId = sessionIdFromCookie; // New session?\n\n        if (!ses && configStateStorageStrategy != 'none') {\n          // New session (aka new visit)\n          visitCount++; // Update the last visit timestamp\n\n          lastVisitTs = currentVisitTs; // Regenerate the session ID\n\n          memorizedSessionId = v4();\n        }\n\n        memorizedVisitCount = visitCount;\n      } else if (new Date().getTime() - lastEventTime > configSessionCookieTimeout * 1000) {\n        memorizedSessionId = v4();\n        memorizedVisitCount++;\n      }\n\n      payloadBuilder.add('vp', detectViewport());\n      payloadBuilder.add('ds', detectDocumentSize());\n      payloadBuilder.add('vid', anonymizeSessionOr(memorizedVisitCount));\n      payloadBuilder.add('sid', anonymizeSessionOr(memorizedSessionId));\n      payloadBuilder.add('duid', anonymizeOr(_domainUserId)); // Set to our local variable\n\n      payloadBuilder.add('uid', anonymizeOr(businessUserId));\n      refreshUrl();\n      payloadBuilder.add('refr', purify(customReferrer || configReferrerUrl)); // Add the page URL last as it may take us over the IE limit (and we don't always need it)\n\n      payloadBuilder.add('url', purify(configCustomUrl || locationHrefAlias)); // Update cookies\n\n      if (configStateStorageStrategy != 'none') {\n        setDomainUserIdCookie(_domainUserId, createTs, memorizedVisitCount, nowTs, lastVisitTs, memorizedSessionId);\n        setSessionCookie();\n      }\n\n      lastEventTime = new Date().getTime();\n    }\n    /**\n     * Adds the protocol in front of our collector URL\n     *\n     * @param string - collectorUrl The collector URL with or without protocol\n     * @returns string collectorUrl The tracker URL with protocol\n     */\n\n\n    function asCollectorUrl(collectorUrl) {\n      if (collectorUrl.indexOf('http') === 0) {\n        return collectorUrl;\n      }\n\n      return ('https:' === document.location.protocol ? 'https' : 'http') + '://' + collectorUrl;\n    }\n    /**\n     * Initialize new `pageViewId` if it shouldn't be preserved.\n     * Should be called when `trackPageView` is invoked\n     */\n\n\n    function resetPageView() {\n      if (!_preservePageViewId || state.pageViewId == null) {\n        state.pageViewId = v4();\n      }\n    }\n    /**\n     * Safe function to get `pageViewId`.\n     * Generates it if it wasn't initialized by other tracker\n     */\n\n\n    function _getPageViewId() {\n      if (state.pageViewId == null) {\n        state.pageViewId = v4();\n      }\n\n      return state.pageViewId;\n    }\n    /**\n     * Put together a web page context with a unique UUID for the page view\n     *\n     * @returns web_page context\n     */\n\n\n    function getWebPagePlugin() {\n      return {\n        contexts: function contexts() {\n          return [{\n            schema: 'iglu:com.snowplowanalytics.snowplow/web_page/jsonschema/1-0-0',\n            data: {\n              id: _getPageViewId()\n            }\n          }];\n        }\n      };\n    }\n    /**\n     * Expires current session and starts a new session.\n     */\n\n\n    function newSession() {\n      // If cookies are enabled, base visit count and session ID on the cookies\n      var nowTs = Math.round(new Date().getTime() / 1000),\n          id = loadDomainUserIdCookie(),\n          cookiesDisabled = id[0],\n          _domainUserId = id[1],\n          // We could use the global (domainUserId) but this is better etiquette\n      createTs = id[2],\n          visitCount = id[3],\n          currentVisitTs = id[4],\n          lastVisitTs = id[5],\n          sessionIdFromCookie = id[6]; // When cookies are enabled\n\n      if (cookiesDisabled === '0') {\n        memorizedSessionId = sessionIdFromCookie; // When cookie/local storage is enabled - make a new session\n\n        if (configStateStorageStrategy != 'none') {\n          // New session (aka new visit)\n          visitCount++; // Update the last visit timestamp\n\n          lastVisitTs = currentVisitTs; // Regenerate the session ID\n\n          memorizedSessionId = v4();\n        }\n\n        memorizedVisitCount = visitCount; // Create a new session cookie\n\n        setSessionCookie();\n      } else {\n        memorizedSessionId = v4();\n        memorizedVisitCount++;\n      } // Update cookies\n\n\n      if (configStateStorageStrategy != 'none') {\n        setDomainUserIdCookie(_domainUserId, createTs, memorizedVisitCount, nowTs, lastVisitTs, memorizedSessionId);\n        setSessionCookie();\n      }\n\n      lastEventTime = new Date().getTime();\n    }\n    /**\n     * Combine an array of unchanging contexts with the result of a context-creating function\n     *\n     * @param staticContexts - Array of custom contexts\n     * @param contextCallback - Function returning an array of contexts\n     */\n\n\n    function finalizeContexts(staticContexts, contextCallback) {\n      return (staticContexts || []).concat(contextCallback ? contextCallback() : []);\n    }\n\n    function logPageView(_a) {\n      var title = _a.title,\n          context = _a.context,\n          timestamp = _a.timestamp,\n          contextCallback = _a.contextCallback;\n      refreshUrl();\n\n      if (pageViewSent) {\n        // Do not reset pageViewId if previous events were not page_view\n        resetPageView();\n      }\n\n      pageViewSent = true; // So we know what document.title was at the time of trackPageView\n\n      lastDocumentTitle = document.title;\n      lastConfigTitle = title; // Fixup page title\n\n      var pageTitle = fixupTitle(lastConfigTitle || lastDocumentTitle); // Log page view\n\n      core.track(buildPageView({\n        pageUrl: purify(configCustomUrl || locationHrefAlias),\n        pageTitle: pageTitle,\n        referrer: purify(customReferrer || configReferrerUrl)\n      }), finalizeContexts(context, contextCallback), timestamp); // Send ping (to log that user has stayed on page)\n\n      var now = new Date();\n      var installingActivityTracking = false;\n\n      if (activityTrackingConfig.enabled && !activityTrackingConfig.installed) {\n        activityTrackingConfig.installed = true;\n        installingActivityTracking = true; // Add mousewheel event handler, detect passive event listeners for performance\n\n        var detectPassiveEvents = {\n          update: function update() {\n            if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n              var passive = false;\n              var options = Object.defineProperty({}, 'passive', {\n                get: function get() {\n                  passive = true;\n                }\n              }); // note: have to set and remove a no-op listener instead of null\n              // (which was used previously), becasue Edge v15 throws an error\n              // when providing a null callback.\n              // https://github.com/rafrex/detect-passive-events/pull/3\n\n              var noop = function noop() {};\n\n              window.addEventListener('testPassiveEventSupport', noop, options);\n              window.removeEventListener('testPassiveEventSupport', noop, options);\n              detectPassiveEvents.hasSupport = passive;\n            }\n          }\n        };\n        detectPassiveEvents.update(); // Detect available wheel event\n\n        var wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' // Modern browsers support \"wheel\"\n        : document.onmousewheel !== undefined ? 'mousewheel' // Webkit and IE support at least \"mousewheel\"\n        : 'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox\n\n        if (Object.prototype.hasOwnProperty.call(detectPassiveEvents, 'hasSupport')) {\n          addEventListener(document, wheelEvent, activityHandler, {\n            passive: true\n          });\n        } else {\n          addEventListener(document, wheelEvent, activityHandler);\n        } // Capture our initial scroll points\n\n\n        resetMaxScrolls(); // Add event handlers; cross-browser compatibility here varies significantly\n        // @see http://quirksmode.org/dom/events\n\n        var documentHandlers = ['click', 'mouseup', 'mousedown', 'mousemove', 'keypress', 'keydown', 'keyup'];\n        var windowHandlers = ['resize', 'focus', 'blur'];\n\n        var listener = function listener(_, handler) {\n          if (handler === void 0) {\n            handler = activityHandler;\n          }\n\n          return function (ev) {\n            return addEventListener(document, ev, handler);\n          };\n        };\n\n        documentHandlers.forEach(listener(document));\n        windowHandlers.forEach(listener(window));\n        listener(window, scrollHandler)('scroll');\n      }\n\n      if (activityTrackingConfig.enabled && (resetActivityTrackingOnPageView || installingActivityTracking)) {\n        // Periodic check for activity.\n        lastActivityTime = now.getTime();\n        var key = void 0;\n\n        for (key in activityTrackingConfig.configurations) {\n          var config = activityTrackingConfig.configurations[key];\n\n          if (config) {\n            //Clear page ping heartbeat on new page view\n            window.clearInterval(config.activityInterval);\n            activityInterval(config, context, contextCallback);\n          }\n        }\n      }\n    }\n\n    function activityInterval(config, context, contextCallback) {\n      var executePagePing = function executePagePing(cb, c) {\n        refreshUrl();\n        cb({\n          context: c,\n          pageViewId: _getPageViewId(),\n          minXOffset: minXOffset,\n          minYOffset: minYOffset,\n          maxXOffset: maxXOffset,\n          maxYOffset: maxYOffset\n        });\n        resetMaxScrolls();\n      };\n\n      var timeout = function timeout() {\n        var now = new Date(); // There was activity during the heart beat period;\n        // on average, this is going to overstate the visitDuration by configHeartBeatTimer/2\n\n        if (lastActivityTime + config.configMinimumVisitLength > now.getTime()) {\n          executePagePing(config.callback, finalizeContexts(context, contextCallback));\n        }\n\n        config.activityInterval = window.setInterval(heartbeat, config.configHeartBeatTimer);\n      };\n\n      var heartbeat = function heartbeat() {\n        var now = new Date(); // There was activity during the heart beat period;\n        // on average, this is going to overstate the visitDuration by configHeartBeatTimer/2\n\n        if (lastActivityTime + config.configHeartBeatTimer > now.getTime()) {\n          executePagePing(config.callback, finalizeContexts(context, contextCallback));\n        }\n      };\n\n      if (config.configMinimumVisitLength != 0) {\n        config.activityInterval = window.setTimeout(timeout, config.configMinimumVisitLength);\n      } else {\n        config.activityInterval = window.setInterval(heartbeat, config.configHeartBeatTimer);\n      }\n    }\n    /**\n     * Configure the activity tracking and ensures integer values for min visit and heartbeat\n     */\n\n\n    function configureActivityTracking(configuration) {\n      var minimumVisitLength = configuration.minimumVisitLength,\n          heartbeatDelay = configuration.heartbeatDelay,\n          callback = configuration.callback;\n\n      if (isInteger(minimumVisitLength) && isInteger(heartbeatDelay)) {\n        return {\n          configMinimumVisitLength: minimumVisitLength * 1000,\n          configHeartBeatTimer: heartbeatDelay * 1000,\n          callback: callback\n        };\n      }\n\n      LOG.warn('Activity tracking not enabled, please provide integer values for minimumVisitLength and heartbeatDelay.');\n      return undefined;\n    }\n    /**\n     * Log that a user is still viewing a given page by sending a page ping.\n     * Not part of the public API - only called from logPageView() above.\n     */\n\n\n    function logPagePing(_a) {\n      var context = _a.context,\n          minXOffset = _a.minXOffset,\n          minYOffset = _a.minYOffset,\n          maxXOffset = _a.maxXOffset,\n          maxYOffset = _a.maxYOffset;\n      var newDocumentTitle = document.title;\n\n      if (newDocumentTitle !== lastDocumentTitle) {\n        lastDocumentTitle = newDocumentTitle;\n        lastConfigTitle = undefined;\n      }\n\n      core.track(buildPagePing({\n        pageUrl: purify(configCustomUrl || locationHrefAlias),\n        pageTitle: fixupTitle(lastConfigTitle || lastDocumentTitle),\n        referrer: purify(customReferrer || configReferrerUrl),\n        minXOffset: cleanOffset(minXOffset),\n        maxXOffset: cleanOffset(maxXOffset),\n        minYOffset: cleanOffset(minYOffset),\n        maxYOffset: cleanOffset(maxYOffset)\n      }), context);\n    }\n\n    var apiMethods = {\n      getDomainSessionIndex: function getDomainSessionIndex() {\n        return memorizedVisitCount;\n      },\n      getPageViewId: function getPageViewId() {\n        return _getPageViewId();\n      },\n      newSession: newSession,\n      getCookieName: function getCookieName(basename) {\n        return getSnowplowCookieName(basename);\n      },\n      getUserId: function getUserId() {\n        return businessUserId;\n      },\n      getDomainUserId: function getDomainUserId() {\n        return loadDomainUserIdCookie()[1];\n      },\n      getDomainUserInfo: function getDomainUserInfo() {\n        return loadDomainUserIdCookie();\n      },\n      setReferrerUrl: function setReferrerUrl(url) {\n        customReferrer = url;\n      },\n      setCustomUrl: function setCustomUrl(url) {\n        refreshUrl();\n        configCustomUrl = resolveRelativeReference(locationHrefAlias, url);\n      },\n      setDocumentTitle: function setDocumentTitle(title) {\n        // So we know what document.title was at the time of trackPageView\n        lastDocumentTitle = document.title;\n        lastConfigTitle = title;\n      },\n      discardHashTag: function discardHashTag(enableFilter) {\n        configDiscardHashTag = enableFilter;\n      },\n      discardBrace: function discardBrace(enableFilter) {\n        configDiscardBrace = enableFilter;\n      },\n      setCookiePath: function setCookiePath(path) {\n        configCookiePath = path;\n        updateDomainHash();\n      },\n      setVisitorCookieTimeout: function setVisitorCookieTimeout(timeout) {\n        configVisitorCookieTimeout = timeout;\n      },\n      crossDomainLinker: function crossDomainLinker(crossDomainLinkerCriterion) {\n        decorateLinks(crossDomainLinkerCriterion);\n      },\n      enableActivityTracking: function enableActivityTracking(configuration) {\n        activityTrackingConfig.enabled = true;\n        activityTrackingConfig.configurations.pagePing = configureActivityTracking(__assign(__assign({}, configuration), {\n          callback: logPagePing\n        }));\n      },\n      enableActivityTrackingCallback: function enableActivityTrackingCallback(configuration) {\n        activityTrackingConfig.enabled = true;\n        activityTrackingConfig.configurations.callback = configureActivityTracking(configuration);\n      },\n      updatePageActivity: function updatePageActivity() {\n        activityHandler();\n      },\n      setOptOutCookie: function setOptOutCookie(name) {\n        configOptOutCookie = name;\n      },\n      setUserId: function setUserId(userId) {\n        businessUserId = userId;\n      },\n      setUserIdFromLocation: function setUserIdFromLocation(querystringField) {\n        refreshUrl();\n        businessUserId = fromQuerystring(querystringField, locationHrefAlias);\n      },\n      setUserIdFromReferrer: function setUserIdFromReferrer(querystringField) {\n        refreshUrl();\n        businessUserId = fromQuerystring(querystringField, configReferrerUrl);\n      },\n      setUserIdFromCookie: function setUserIdFromCookie(cookieName) {\n        businessUserId = cookie(cookieName);\n      },\n      setCollectorUrl: function setCollectorUrl(collectorUrl) {\n        configCollectorUrl = asCollectorUrl(collectorUrl);\n        outQueue.setCollectorUrl(configCollectorUrl);\n      },\n      setBufferSize: function setBufferSize(newBufferSize) {\n        outQueue.setBufferSize(newBufferSize);\n      },\n      flushBuffer: function flushBuffer(configuration) {\n        if (configuration === void 0) {\n          configuration = {};\n        }\n\n        outQueue.executeQueue();\n\n        if (configuration.newBufferSize) {\n          outQueue.setBufferSize(configuration.newBufferSize);\n        }\n      },\n      trackPageView: function trackPageView(event) {\n        if (event === void 0) {\n          event = {};\n        }\n\n        logPageView(event);\n      },\n      preservePageViewId: function preservePageViewId() {\n        _preservePageViewId = true;\n      },\n      disableAnonymousTracking: function disableAnonymousTracking(configuration) {\n        trackerConfiguration.anonymousTracking = false;\n        toggleAnonymousTracking(configuration);\n        initializeIdsAndCookies();\n        outQueue.executeQueue(); // There might be some events in the queue we've been unable to send in anonymous mode\n      },\n      enableAnonymousTracking: function enableAnonymousTracking(configuration) {\n        trackerConfiguration.anonymousTracking = configuration && (configuration === null || configuration === void 0 ? void 0 : configuration.options) || true;\n        toggleAnonymousTracking(configuration); // Reset the page view, if not tracking the session, so can't stitch user into new events on the page view id\n\n        if (!configAnonymousSessionTracking) {\n          resetPageView();\n        }\n      },\n      clearUserData: clearUserDataAndCookies\n    };\n    return __assign(__assign({}, apiMethods), {\n      id: trackerId,\n      namespace: namespace,\n      core: core,\n      sharedState: state\n    });\n  }; // Initialise the tracker\n\n\n  var partialTracker = newTracker(trackerId, namespace, version, endpoint, sharedState, trackerConfiguration),\n      tracker = __assign(__assign({}, partialTracker), {\n    addPlugin: function addPlugin(configuration) {\n      var _a, _b;\n\n      tracker.core.addPlugin(configuration);\n      (_b = (_a = configuration.plugin).activateBrowserPlugin) === null || _b === void 0 ? void 0 : _b.call(_a, tracker);\n    }\n  }); // Initialise each plugin with the tracker\n\n\n  (_a = trackerConfiguration.plugins) === null || _a === void 0 ? void 0 : _a.forEach(function (p) {\n    var _a;\n\n    (_a = p.activateBrowserPlugin) === null || _a === void 0 ? void 0 : _a.call(p, tracker);\n  });\n  return tracker;\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nvar namedTrackers = {};\n/**\n * Dispatch function to all specified trackers\n *\n * @param trackers - An optional list of trackers to send the event to, or will send to all trackers\n * @param fn - The function which will run against each tracker\n */\n\nfunction dispatchToTrackers(trackers, fn) {\n  try {\n    getTrackers(trackers !== null && trackers !== void 0 ? trackers : allTrackerNames()).forEach(fn);\n  } catch (ex) {\n    LOG.error('Function failed', ex);\n  }\n}\n/**\n * Dispatch function to all specified trackers from the supplied collection\n *\n * @param trackers - An optional list of trackers to send the event to, or will send to all trackers\n * @param trackerCollection - The collection which the trackers will be selected from\n * @param fn - The function which will run against each tracker\n */\n\n\nfunction dispatchToTrackersInCollection(trackers, trackerCollection, fn) {\n  try {\n    getTrackersFromCollection(trackers !== null && trackers !== void 0 ? trackers : Object.keys(trackerCollection), trackerCollection).forEach(fn);\n  } catch (ex) {\n    LOG.error('Function failed', ex);\n  }\n}\n/**\n * Checks if a tracker has been created for a particular identifier\n * @param trackerId - The unique identifier of the tracker\n */\n\n\nfunction trackerExists(trackerId) {\n  return namedTrackers.hasOwnProperty(trackerId);\n}\n/**\n * Creates a Tracker and adds it to the internal collection\n * @param trackerId - The unique identifier of the tracker\n * @param namespace - The namespace of the tracker, tracked with each event as `tna`\n * @param version - The current version of the tracker library\n * @param endpoint - The endpoint to send events to\n * @param sharedState - The instance of shared state to use for this tracker\n * @param configuration - The configuration to use for this tracker instance\n */\n\n\nfunction addTracker(trackerId, namespace, version, endpoint, sharedState, configuration) {\n  if (!namedTrackers.hasOwnProperty(trackerId)) {\n    namedTrackers[trackerId] = Tracker(trackerId, namespace, version, endpoint, sharedState, configuration);\n    return namedTrackers[trackerId];\n  }\n\n  return null;\n}\n/**\n * Gets a single instance of the internal tracker object\n * @param trackerId - The unique identifier of the tracker\n * @returns The tracker instance, or null if not found\n */\n\n\nfunction getTracker(trackerId) {\n  if (namedTrackers.hasOwnProperty(trackerId)) {\n    return namedTrackers[trackerId];\n  }\n\n  LOG.warn(trackerId + ' not configured');\n  return null;\n}\n/**\n * Gets an array of tracker instances based on the list of identifiers\n * @param trackerIds - An array of unique identifiers of the trackers\n * @returns The tracker instances, or empty list if none found\n */\n\n\nfunction getTrackers(trackerIds) {\n  return getTrackersFromCollection(trackerIds, namedTrackers);\n}\n/**\n * Gets all the trackers as a object, keyed by their unique identifiers\n */\n\n\nfunction allTrackers() {\n  return namedTrackers;\n}\n/**\n * Returns all the unique tracker identifiers\n */\n\n\nfunction allTrackerNames() {\n  return Object.keys(namedTrackers);\n}\n\nfunction getTrackersFromCollection(trackerIds, trackerCollection) {\n  var trackers = [];\n\n  for (var _i = 0, trackerIds_1 = trackerIds; _i < trackerIds_1.length; _i++) {\n    var id = trackerIds_1[_i];\n\n    if (trackerCollection.hasOwnProperty(id)) {\n      trackers.push(trackerCollection[id]);\n    } else {\n      LOG.warn(id + ' not configured');\n    }\n  }\n\n  return trackers;\n}\n/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * A set of variables which are shared among all initialised trackers\n */\n\n\nvar SharedState =\n/** @class */\nfunction () {\n  function SharedState() {\n    /* List of request queues - one per Tracker instance */\n    this.outQueues = [];\n    this.bufferFlushers = [];\n    /* DOM Ready */\n\n    this.hasLoaded = false;\n    this.registeredOnLoadHandlers = [];\n  }\n\n  return SharedState;\n}();\n\nfunction createSharedState() {\n  var sharedState = new SharedState(),\n      documentAlias = document,\n      windowAlias = window;\n  /*\n   * Handle page visibility event\n   * Works everywhere except IE9\n   */\n\n  function visibilityChangeHandler() {\n    if (documentAlias.visibilityState == 'hidden') {\n      // Flush all POST queues\n      sharedState.bufferFlushers.forEach(function (flusher) {\n        flusher(false);\n      });\n    }\n  }\n\n  function flushBuffers() {\n    // Flush all POST queues\n    sharedState.bufferFlushers.forEach(function (flusher) {\n      flusher(false);\n    });\n  }\n  /*\n   * Handler for onload event\n   */\n\n\n  function loadHandler() {\n    var i;\n\n    if (!sharedState.hasLoaded) {\n      sharedState.hasLoaded = true;\n\n      for (i = 0; i < sharedState.registeredOnLoadHandlers.length; i++) {\n        sharedState.registeredOnLoadHandlers[i]();\n      }\n    }\n\n    return true;\n  }\n  /*\n   * Add onload or DOM ready handler\n   */\n\n\n  function addReadyListener() {\n    if (documentAlias.addEventListener) {\n      documentAlias.addEventListener('DOMContentLoaded', function ready() {\n        documentAlias.removeEventListener('DOMContentLoaded', ready, false);\n        loadHandler();\n      });\n    } else if (documentAlias.attachEvent) {\n      documentAlias.attachEvent('onreadystatechange', function ready() {\n        if (documentAlias.readyState === 'complete') {\n          documentAlias.detachEvent('onreadystatechange', ready);\n          loadHandler();\n        }\n      });\n    } // fallback\n\n\n    addEventListener(windowAlias, 'load', loadHandler, false);\n  }\n  /************************************************************\n   * Constructor\n   ************************************************************/\n  // initialize the Snowplow singleton\n\n\n  if (documentAlias.visibilityState) {\n    // Flush for mobile and modern browsers\n    addEventListener(documentAlias, 'visibilitychange', visibilityChangeHandler, false);\n  } // Last attempt at flushing in beforeunload\n\n\n  addEventListener(windowAlias, 'beforeunload', flushBuffers, false);\n\n  if (document.readyState === 'loading') {\n    addReadyListener();\n  } else {\n    loadHandler();\n  }\n\n  return sharedState;\n}\n\nexport { SharedState, addEventListener, addTracker, allTrackerNames, allTrackers, attemptDeleteLocalStorage, attemptGetLocalStorage, attemptGetSessionStorage, attemptWriteLocalStorage, attemptWriteSessionStorage, cookie, createSharedState, decorateQuerystring, deleteCookie, detectDocumentSize, detectViewport, dispatchToTrackers, dispatchToTrackersInCollection, findRootDomain, fixupDomain, fixupTitle, fixupUrl, fromQuerystring, getCookiesWithPrefix, getCssClasses, getFilterByClass, getFilterByName, getHostName, getReferrer, getTracker, getTrackers, hasLocalStorage, hasSessionStorage, isFunction, isInteger, isString, isValueInArray, localStorageAccessible, parseAndValidateFloat, parseAndValidateInt, trackerExists };","map":{"version":3,"sources":["../src/detectors.ts","../src/helpers.ts","../src/tracker/out_queue.ts","../src/proxies.ts","../src/tracker/index.ts","../src/snowplow.ts","../src/state.ts"],"names":["uuid"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Checks whether sessionStorage is available, in a way that\n * does not throw a SecurityError in Firefox if \"always ask\"\n * is enabled for cookies (https://github.com/snowplow/snowplow/issues/163).\n */\nexport function hasSessionStorage() {\n  try {\n    return !!window.sessionStorage;\n  } catch (e) {\n    return true; // SecurityError when referencing it means it exists\n  }\n}\n\n/*\n * Checks whether localStorage is available, in a way that\n * does not throw a SecurityError in Firefox if \"always ask\"\n * is enabled for cookies (https://github.com/snowplow/snowplow/issues/163).\n */\nexport function hasLocalStorage() {\n  try {\n    return !!window.localStorage;\n  } catch (e) {\n    return true; // SecurityError when referencing it means it exists\n  }\n}\n\n/*\n * Checks whether localStorage is accessible\n * sets and removes an item to handle private IOS5 browsing\n * (http://git.io/jFB2Xw)\n */\nexport function localStorageAccessible() {\n  var mod = 'modernizr';\n  if (!hasLocalStorage()) {\n    return false;\n  }\n  try {\n    const ls = window.localStorage;\n    ls.setItem(mod, mod);\n    ls.removeItem(mod);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Gets the current viewport.\n *\n * Code based on:\n * - http://andylangton.co.uk/articles/javascript/get-viewport-size-javascript/\n * - http://responsejs.com/labs/dimensions/\n */\nexport function detectViewport() {\n  var width, height;\n\n  if ('innerWidth' in window) {\n    width = window['innerWidth'];\n    height = window['innerHeight'];\n  } else {\n    const e = document.documentElement || document.body;\n    width = e['clientWidth'];\n    height = e['clientHeight'];\n  }\n\n  if (width >= 0 && height >= 0) {\n    return width + 'x' + height;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Gets the dimensions of the current\n * document.\n *\n * Code based on:\n * - http://andylangton.co.uk/articles/javascript/get-viewport-size-javascript/\n */\nexport function detectDocumentSize() {\n  var de = document.documentElement, // Alias\n    be = document.body,\n    // document.body may not have rendered, so check whether be.offsetHeight is null\n    bodyHeight = be ? Math.max(be.offsetHeight, be.scrollHeight) : 0;\n  var w = Math.max(de.clientWidth, de.offsetWidth, de.scrollWidth);\n  var h = Math.max(de.clientHeight, de.offsetHeight, de.scrollHeight, bodyHeight);\n  return isNaN(w) || isNaN(h) ? '' : w + 'x' + h;\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndeclare global {\n  interface EventTarget {\n    attachEvent?: (type: string, fn: EventListenerOrEventListenerObject) => void;\n  }\n}\n\n/**\n * The criteria which will be used to filter results to specific classes or elements\n */\nexport interface FilterCriterion<T> {\n  /** A collection of class names to include */\n  allowlist?: string[];\n  /** A collector of class names to exclude */\n  denylist?: string[];\n  /** A callback which returns a boolean as to whether the element should be included */\n  filter?: (elt: T) => boolean;\n}\n\n/**\n * Checks if an object is a string\n * @param str - The object to check\n */\nexport function isString(str: Object): str is string {\n  if (str && typeof str.valueOf() === 'string') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Checks if an object is an integer\n * @param int - The object to check\n */\nexport function isInteger(int: Object): int is number {\n  return (\n    (Number.isInteger && Number.isInteger(int)) || (typeof int === 'number' && isFinite(int) && Math.floor(int) === int)\n  );\n}\n\n/**\n * Checks if the input parameter is a function\n * @param func - The object to check\n */\nexport function isFunction(func: unknown) {\n  if (func && typeof func === 'function') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Cleans up the page title\n */\nexport function fixupTitle(title: string | { text: string }) {\n  if (!isString(title)) {\n    title = title.text || '';\n\n    var tmp = document.getElementsByTagName('title');\n    if (tmp && tmp[0] != null) {\n      title = tmp[0].text;\n    }\n  }\n  return title;\n}\n\n/**\n * Extract hostname from URL\n */\nexport function getHostName(url: string) {\n  // scheme : // [username [: password] @] hostname [: port] [/ [path] [? query] [# fragment]]\n  var e = new RegExp('^(?:(?:https?|ftp):)/*(?:[^@]+@)?([^:/#]+)'),\n    matches = e.exec(url);\n\n  return matches ? matches[1] : url;\n}\n\n/**\n * Fix-up domain\n */\nexport function fixupDomain(domain: string) {\n  var dl = domain.length;\n\n  // remove trailing '.'\n  if (domain.charAt(--dl) === '.') {\n    domain = domain.slice(0, dl);\n  }\n  // remove leading '*'\n  if (domain.slice(0, 2) === '*.') {\n    domain = domain.slice(1);\n  }\n  return domain;\n}\n\n/**\n * Get page referrer. In the case of a single-page app,\n * if the URL changes without the page reloading, pass\n * in the old URL. It will be returned unless overriden\n * by a \"refer(r)er\" parameter in the querystring.\n *\n * @param string - oldLocation Optional.\n * @return string The referrer\n */\nexport function getReferrer(oldLocation?: string) {\n  let windowAlias = window,\n    referrer = '',\n    fromQs =\n      fromQuerystring('referrer', windowAlias.location.href) || fromQuerystring('referer', windowAlias.location.href);\n\n  // Short-circuit\n  if (fromQs) {\n    return fromQs;\n  }\n\n  // In the case of a single-page app, return the old URL\n  if (oldLocation) {\n    return oldLocation;\n  }\n\n  try {\n    referrer = windowAlias.top.document.referrer;\n  } catch (e) {\n    if (windowAlias.parent) {\n      try {\n        referrer = windowAlias.parent.document.referrer;\n      } catch (e2) {\n        referrer = '';\n      }\n    }\n  }\n  if (referrer === '') {\n    referrer = document.referrer;\n  }\n  return referrer;\n}\n\n/**\n * Cross-browser helper function to add event handler\n */\nexport function addEventListener(\n  element: HTMLElement | EventTarget,\n  eventType: string,\n  eventHandler: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions\n) {\n  if (element.addEventListener) {\n    element.addEventListener(eventType, eventHandler, options);\n    return true;\n  }\n\n  // IE Support\n  if (element.attachEvent) {\n    return element.attachEvent('on' + eventType, eventHandler);\n  }\n  (element as any)['on' + eventType] = eventHandler;\n}\n\n/**\n * Return value from name-value pair in querystring\n */\nexport function fromQuerystring(field: string, url: string) {\n  var match = new RegExp('^[^#]*[?&]' + field + '=([^&#]*)').exec(url);\n  if (!match) {\n    return null;\n  }\n  return decodeURIComponent(match[1].replace(/\\+/g, ' '));\n}\n\n/**\n * Add a name-value pair to the querystring of a URL\n *\n * @param string - url URL to decorate\n * @param string - name Name of the querystring pair\n * @param string - value Value of the querystring pair\n */\nexport function decorateQuerystring(url: string, name: string, value: string) {\n  var initialQsParams = name + '=' + value;\n  var hashSplit = url.split('#');\n  var qsSplit = hashSplit[0].split('?');\n  var beforeQuerystring = qsSplit.shift();\n  // Necessary because a querystring may contain multiple question marks\n  var querystring = qsSplit.join('?');\n  if (!querystring) {\n    querystring = initialQsParams;\n  } else {\n    // Whether this is the first time the link has been decorated\n    var initialDecoration = true;\n    var qsFields = querystring.split('&');\n    for (var i = 0; i < qsFields.length; i++) {\n      if (qsFields[i].substr(0, name.length + 1) === name + '=') {\n        initialDecoration = false;\n        qsFields[i] = initialQsParams;\n        querystring = qsFields.join('&');\n        break;\n      }\n    }\n    if (initialDecoration) {\n      querystring = initialQsParams + '&' + querystring;\n    }\n  }\n  hashSplit[0] = beforeQuerystring + '?' + querystring;\n  return hashSplit.join('#');\n}\n\n/**\n * Attempt to get a value from localStorage\n *\n * @param string - key\n * @return string The value obtained from localStorage, or\n *                undefined if localStorage is inaccessible\n */\nexport function attemptGetLocalStorage(key: string) {\n  try {\n    const localStorageAlias = window.localStorage,\n      exp = localStorageAlias.getItem(key + '.expires');\n    if (exp === null || +exp > Date.now()) {\n      return localStorageAlias.getItem(key);\n    } else {\n      localStorageAlias.removeItem(key);\n      localStorageAlias.removeItem(key + '.expires');\n    }\n    return undefined;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Attempt to write a value to localStorage\n *\n * @param string - key\n * @param string - value\n * @param number - ttl Time to live in seconds, defaults to 2 years from Date.now()\n * @return boolean Whether the operation succeeded\n */\nexport function attemptWriteLocalStorage(key: string, value: string, ttl = 63072000) {\n  try {\n    const localStorageAlias = window.localStorage,\n      t = Date.now() + ttl * 1000;\n    localStorageAlias.setItem(`${key}.expires`, t.toString());\n    localStorageAlias.setItem(key, value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Attempt to delete a value from localStorage\n *\n * @param string - key\n * @return boolean Whether the operation succeeded\n */\nexport function attemptDeleteLocalStorage(key: string) {\n  try {\n    const localStorageAlias = window.localStorage;\n    localStorageAlias.removeItem(key);\n    localStorageAlias.removeItem(key + '.expires');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Attempt to get a value from sessionStorage\n *\n * @param string - key\n * @return string The value obtained from sessionStorage, or\n *                undefined if sessionStorage is inaccessible\n */\nexport function attemptGetSessionStorage(key: string) {\n  try {\n    return window.sessionStorage.getItem(key);\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Attempt to write a value to sessionStorage\n *\n * @param string - key\n * @param string - value\n * @return boolean Whether the operation succeeded\n */\nexport function attemptWriteSessionStorage(key: string, value: string) {\n  try {\n    window.sessionStorage.setItem(key, value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Finds the root domain\n */\nexport function findRootDomain(sameSite: string, secure: boolean) {\n  const windowLocationHostnameAlias = window.location.hostname,\n    cookiePrefix = '_sp_root_domain_test_',\n    cookieName = cookiePrefix + new Date().getTime(),\n    cookieValue = '_test_value_' + new Date().getTime();\n\n  var split = windowLocationHostnameAlias.split('.');\n  var position = split.length - 1;\n  while (position >= 0) {\n    var currentDomain = split.slice(position, split.length).join('.');\n    cookie(cookieName, cookieValue, 0, '/', currentDomain, sameSite, secure);\n    if (cookie(cookieName) === cookieValue) {\n      // Clean up created cookie(s)\n      deleteCookie(cookieName, currentDomain, sameSite, secure);\n      var cookieNames = getCookiesWithPrefix(cookiePrefix);\n      for (var i = 0; i < cookieNames.length; i++) {\n        deleteCookie(cookieNames[i], currentDomain, sameSite, secure);\n      }\n\n      return currentDomain;\n    }\n    position -= 1;\n  }\n\n  // Cookies cannot be read\n  return windowLocationHostnameAlias;\n}\n\n/**\n * Checks whether a value is present within an array\n *\n * @param val - The value to check for\n * @param array - The array to check within\n * @return boolean Whether it exists\n */\nexport function isValueInArray<T>(val: T, array: T[]) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === val) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Deletes an arbitrary cookie by setting the expiration date to the past\n *\n * @param cookieName - The name of the cookie to delete\n * @param domainName - The domain the cookie is in\n */\nexport function deleteCookie(cookieName: string, domainName?: string, sameSite?: string, secure?: boolean) {\n  cookie(cookieName, '', -1, '/', domainName, sameSite, secure);\n}\n\n/**\n * Fetches the name of all cookies beginning with a certain prefix\n *\n * @param cookiePrefix - The prefix to check for\n * @return array The cookies that begin with the prefix\n */\nexport function getCookiesWithPrefix(cookiePrefix: string) {\n  var cookies = document.cookie.split('; ');\n  var cookieNames = [];\n  for (var i = 0; i < cookies.length; i++) {\n    if (cookies[i].substring(0, cookiePrefix.length) === cookiePrefix) {\n      cookieNames.push(cookies[i]);\n    }\n  }\n  return cookieNames;\n}\n\n/**\n * Get and set the cookies associated with the current document in browser\n * This implementation always returns a string, returns the cookie value if only name is specified\n *\n * @param name - The cookie name (required)\n * @param value - The cookie value\n * @param ttl - The cookie Time To Live (seconds)\n * @param path - The cookies path\n * @param domain - The cookies domain\n * @param samesite - The cookies samesite attribute\n * @param secure - Boolean to specify if cookie should be secure\n * @return string The cookies value\n */\nexport function cookie(\n  name: string,\n  value?: string,\n  ttl?: number,\n  path?: string,\n  domain?: string,\n  samesite?: string,\n  secure?: boolean\n) {\n  if (arguments.length > 1) {\n    return (document.cookie =\n      name +\n      '=' +\n      encodeURIComponent(value ?? '') +\n      (ttl ? '; Expires=' + new Date(+new Date() + ttl * 1000).toUTCString() : '') +\n      (path ? '; Path=' + path : '') +\n      (domain ? '; Domain=' + domain : '') +\n      (samesite ? '; SameSite=' + samesite : '') +\n      (secure ? '; Secure' : ''));\n  }\n\n  return decodeURIComponent((('; ' + document.cookie).split('; ' + name + '=')[1] || '').split(';')[0]);\n}\n\n/**\n * Parses an object and returns either the\n * integer or undefined.\n *\n * @param obj - The object to parse\n * @return the result of the parse operation\n */\nexport function parseAndValidateInt(obj: unknown) {\n  var result = parseInt(obj as string);\n  return isNaN(result) ? undefined : result;\n}\n\n/**\n * Parses an object and returns either the\n * number or undefined.\n *\n * @param obj - The object to parse\n * @return the result of the parse operation\n */\nexport function parseAndValidateFloat(obj: unknown) {\n  var result = parseFloat(obj as string);\n  return isNaN(result) ? undefined : result;\n}\n\n/**\n * Convert a criterion object to a filter function\n *\n * @param object - criterion Either {allowlist: [array of allowable strings]}\n *                             or {denylist: [array of allowable strings]}\n *                             or {filter: function (elt) {return whether to track the element}\n * @param boolean - byClass Whether to allowlist/denylist based on an element's classes (for forms)\n *                        or name attribute (for fields)\n */\nexport function getFilterByClass(criterion?: FilterCriterion<HTMLElement> | null): (elt: HTMLElement) => boolean {\n  // If the criterion argument is not an object, add listeners to all elements\n  if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {\n    return function () {\n      return true;\n    };\n  }\n\n  const inclusive = Object.prototype.hasOwnProperty.call(criterion, 'allowlist');\n  const specifiedClassesSet = getSpecifiedClassesSet(criterion);\n\n  return getFilter(criterion, function (elt: HTMLElement) {\n    return checkClass(elt, specifiedClassesSet) === inclusive;\n  });\n}\n\n/**\n * Convert a criterion object to a filter function\n *\n * @param object - criterion Either {allowlist: [array of allowable strings]}\n *                             or {denylist: [array of allowable strings]}\n *                             or {filter: function (elt) {return whether to track the element}\n */\nexport function getFilterByName<T extends { name: string }>(criterion?: FilterCriterion<T>): (elt: T) => boolean {\n  // If the criterion argument is not an object, add listeners to all elements\n  if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {\n    return function () {\n      return true;\n    };\n  }\n\n  const inclusive = criterion.hasOwnProperty('allowlist');\n  const specifiedClassesSet = getSpecifiedClassesSet(criterion);\n\n  return getFilter(criterion, function (elt: T) {\n    return elt.name in specifiedClassesSet === inclusive;\n  });\n}\n\n/**\n * List the classes of a DOM element without using elt.classList (for compatibility with IE 9)\n */\nexport function getCssClasses(elt: Element) {\n  return elt.className.match(/\\S+/g) || [];\n}\n\n/**\n * Check whether an element has at least one class from a given list\n */\nfunction checkClass(elt: Element, classList: Record<string, boolean>) {\n  var classes = getCssClasses(elt);\n\n  for (const className of classes) {\n    if (classList[className]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getFilter<T>(criterion: FilterCriterion<T>, fallbackFilter: (elt: T) => boolean) {\n  if (criterion.hasOwnProperty('filter') && criterion.filter) {\n    return criterion.filter;\n  }\n\n  return fallbackFilter;\n}\n\nfunction getSpecifiedClassesSet<T>(criterion: FilterCriterion<T>) {\n  // Convert the array of classes to an object of the form {class1: true, class2: true, ...}\n  var specifiedClassesSet: Record<string, boolean> = {};\n  var specifiedClasses = criterion.allowlist || criterion.denylist;\n\n  if (specifiedClasses) {\n    if (!Array.isArray(specifiedClasses)) {\n      specifiedClasses = [specifiedClasses];\n    }\n\n    for (var i = 0; i < specifiedClasses.length; i++) {\n      specifiedClassesSet[specifiedClasses[i]] = true;\n    }\n  }\n\n  return specifiedClassesSet;\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { attemptWriteLocalStorage, isString } from '../helpers';\nimport { SharedState } from '../state';\nimport { localStorageAccessible } from '../detectors';\nimport { LOG, Payload } from '@snowplow/tracker-core';\n\nexport interface OutQueue {\n  enqueueRequest: (request: Payload, url: string) => void;\n  executeQueue: () => void;\n  setUseLocalStorage: (localStorage: boolean) => void;\n  setAnonymousTracking: (anonymous: boolean) => void;\n  setCollectorUrl: (url: string) => void;\n  setBufferSize: (bufferSize: number) => void;\n}\n\n/**\n * Object handling sending events to a collector.\n * Instantiated once per tracker instance.\n *\n * @param id - The Snowplow function name (used to generate the localStorage key)\n * @param sharedSate - Stores reference to the outbound queue so it can unload the page when all queues are empty\n * @param useLocalStorage - Whether to use localStorage at all\n * @param eventMethod - if null will use 'beacon' otherwise can be set to 'post', 'get', or 'beacon' to force.\n * @param postPath - The path where events are to be posted\n * @param bufferSize - How many events to batch in localStorage before sending them all\n * @param maxPostBytes - Maximum combined size in bytes of the event JSONs in a POST request\n * @param useStm - Whether to add timestamp to events\n * @param maxLocalStorageQueueSize - Maximum number of queued events we will attempt to store in local storage\n * @param connectionTimeout - Defines how long to wait before aborting the request\n * @param anonymousTracking - Defines whether to set the SP-Anonymous header for anonymous tracking on GET and POST\n * @returns object OutQueueManager instance\n */\nexport function OutQueueManager(\n  id: string,\n  sharedSate: SharedState,\n  useLocalStorage: boolean,\n  eventMethod: string | boolean | null,\n  postPath: string,\n  bufferSize: number,\n  maxPostBytes: number,\n  useStm: boolean,\n  maxLocalStorageQueueSize: number,\n  connectionTimeout: number,\n  anonymousTracking: boolean\n): OutQueue {\n  type PostEvent = {\n    evt: Record<string, unknown>;\n    bytes: number;\n  };\n\n  let executingQueue = false,\n    configCollectorUrl: string,\n    outQueue: Array<PostEvent> | Array<string> = [];\n\n  //Force to lower case if its a string\n  eventMethod = typeof eventMethod === 'string' ? eventMethod.toLowerCase() : eventMethod;\n\n  // Use the Beacon API if eventMethod is set null, true, or 'beacon'.\n  const localStorageAlias = window.localStorage,\n    navigatorAlias = window.navigator,\n    isBeaconRequested =\n      eventMethod === null || eventMethod === true || eventMethod === 'beacon' || eventMethod === 'true',\n    // Fall back to POST or GET for browsers which don't support Beacon API\n    isBeaconAvailable = Boolean(\n      isBeaconRequested && navigatorAlias && navigatorAlias.sendBeacon && !hasWebKitBeaconBug(navigatorAlias.userAgent)\n    ),\n    useBeacon = isBeaconAvailable && isBeaconRequested,\n    // Use GET if specified\n    isGetRequested = eventMethod === 'get',\n    // Don't use XhrHttpRequest for browsers which don't support CORS XMLHttpRequests (e.g. IE <= 9)\n    useXhr = Boolean(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),\n    // Use POST if specified\n    usePost = !isGetRequested && useXhr && (eventMethod === 'post' || isBeaconRequested),\n    // Resolve all options and capabilities and decide path\n    path = usePost ? postPath : '/i',\n    // Different queue names for GET and POST since they are stored differently\n    queueName = `snowplowOutQueue_${id}_${usePost ? 'post2' : 'get'}`;\n\n  // Get buffer size or set 1 if unable to buffer\n  bufferSize = (localStorageAccessible() && useLocalStorage && usePost && bufferSize) || 1;\n\n  if (useLocalStorage) {\n    // Catch any JSON parse errors or localStorage that might be thrown\n    try {\n      const localStorageQueue = localStorageAlias.getItem(queueName);\n      outQueue = localStorageQueue ? JSON.parse(localStorageQueue) : [];\n    } catch (e) {}\n  }\n\n  // Initialize to and empty array if we didn't get anything out of localStorage\n  if (!Array.isArray(outQueue)) {\n    outQueue = [];\n  }\n\n  // Used by pageUnloadGuard\n  sharedSate.outQueues.push(outQueue);\n\n  if (useXhr && bufferSize > 1) {\n    sharedSate.bufferFlushers.push(function (sync) {\n      if (!executingQueue) {\n        executeQueue(sync);\n      }\n    });\n  }\n\n  /*\n   * Convert a dictionary to a querystring\n   * The context field is the last in the querystring\n   */\n  function getQuerystring(request: Payload) {\n    let querystring = '?',\n      lowPriorityKeys = { co: true, cx: true },\n      firstPair = true;\n\n    for (const key in request) {\n      if (request.hasOwnProperty(key) && !lowPriorityKeys.hasOwnProperty(key)) {\n        if (!firstPair) {\n          querystring += '&';\n        } else {\n          firstPair = false;\n        }\n        querystring += encodeURIComponent(key) + '=' + encodeURIComponent(request[key] as string | number | boolean);\n      }\n    }\n\n    for (const contextKey in lowPriorityKeys) {\n      if (request.hasOwnProperty(contextKey) && lowPriorityKeys.hasOwnProperty(contextKey)) {\n        querystring += '&' + contextKey + '=' + encodeURIComponent(request[contextKey] as string | number | boolean);\n      }\n    }\n\n    return querystring;\n  }\n\n  /*\n   * Convert numeric fields to strings to match payload_data schema\n   */\n  function getBody(request: Payload): PostEvent {\n    const cleanedRequest = Object.keys(request)\n      .map<[string, unknown]>((k) => [k, request[k]])\n      .reduce((acc, [key, value]) => {\n        acc[key] = (value as Object).toString();\n        return acc;\n      }, {} as Record<string, unknown>);\n    return {\n      evt: cleanedRequest,\n      bytes: getUTF8Length(JSON.stringify(cleanedRequest)),\n    };\n  }\n\n  /**\n   * Count the number of bytes a string will occupy when UTF-8 encoded\n   * Taken from http://stackoverflow.com/questions/2848462/count-bytes-in-textarea-using-javascript/\n   *\n   * @param string - s\n   * @return number Length of s in bytes when UTF-8 encoded\n   */\n  function getUTF8Length(s: string) {\n    let len = 0;\n    for (let i = 0; i < s.length; i++) {\n      const code = s.charCodeAt(i);\n      if (code <= 0x7f) {\n        len += 1;\n      } else if (code <= 0x7ff) {\n        len += 2;\n      } else if (code >= 0xd800 && code <= 0xdfff) {\n        // Surrogate pair: These take 4 bytes in UTF-8 and 2 chars in UCS-2\n        // (Assume next char is the other [valid] half and just skip it)\n        len += 4;\n        i++;\n      } else if (code < 0xffff) {\n        len += 3;\n      } else {\n        len += 4;\n      }\n    }\n    return len;\n  }\n\n  const postable = (queue: Array<PostEvent> | Array<string>): queue is Array<PostEvent> => {\n    return typeof queue[0] === 'object';\n  };\n\n  /*\n   * Queue for submission to the collector and start processing queue\n   */\n  function enqueueRequest(request: Payload, url: string) {\n    configCollectorUrl = url + path;\n    if (usePost) {\n      const body = getBody(request);\n      if (body.bytes >= maxPostBytes) {\n        LOG.warn('Event (' + body.bytes + 'B) too big, max is ' + maxPostBytes);\n        const xhr = initializeXMLHttpRequest(configCollectorUrl, true, false);\n        xhr.send(encloseInPayloadDataEnvelope(attachStmToEvent([body.evt])));\n        return;\n      } else {\n        (outQueue as Array<PostEvent>).push(body);\n      }\n    } else {\n      (outQueue as Array<string>).push(getQuerystring(request));\n    }\n    let savedToLocalStorage = false;\n    if (useLocalStorage) {\n      savedToLocalStorage = attemptWriteLocalStorage(\n        queueName,\n        JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize))\n      );\n    }\n\n    // If we're not processing the queue, we'll start.\n    if (!executingQueue && (!savedToLocalStorage || outQueue.length >= bufferSize)) {\n      executeQueue();\n    }\n  }\n\n  /*\n   * Run through the queue of requests, sending them one at a time.\n   * Stops processing when we run out of queued requests, or we get an error.\n   */\n  function executeQueue(sync: boolean = false) {\n    // Failsafe in case there is some way for a bad value like \"null\" to end up in the outQueue\n    while (outQueue.length && typeof outQueue[0] !== 'string' && typeof outQueue[0] !== 'object') {\n      outQueue.shift();\n    }\n\n    if (outQueue.length < 1) {\n      executingQueue = false;\n      return;\n    }\n\n    // Let's check that we have a URL\n    if (!isString(configCollectorUrl)) {\n      throw 'No collector configured';\n    }\n\n    executingQueue = true;\n\n    if (useXhr) {\n      // Keep track of number of events to delete from queue\n      const chooseHowManyToSend = (queue: Array<{ bytes: number }>) => {\n        let numberToSend = 0,\n          byteCount = 0;\n        while (numberToSend < queue.length) {\n          byteCount += queue[numberToSend].bytes;\n          if (byteCount >= maxPostBytes) {\n            break;\n          } else {\n            numberToSend += 1;\n          }\n        }\n        return numberToSend;\n      };\n\n      let url: string, xhr: XMLHttpRequest, numberToSend: number;\n      if (postable(outQueue)) {\n        url = configCollectorUrl;\n        xhr = initializeXMLHttpRequest(url, true, sync);\n        numberToSend = chooseHowManyToSend(outQueue);\n      } else {\n        url = createGetUrl(outQueue[0]);\n        xhr = initializeXMLHttpRequest(url, false, sync);\n        numberToSend = 1;\n      }\n\n      // Time out POST requests after connectionTimeout\n      const xhrTimeout = setTimeout(function () {\n        xhr.abort();\n        executingQueue = false;\n      }, connectionTimeout);\n\n      // The events (`numberToSend` of them), have been sent, so we remove them from the outQueue\n      // We also call executeQueue() again, to let executeQueue() check if we should keep running through the queue\n      const onPostSuccess = (numberToSend: number): void => {\n        for (let deleteCount = 0; deleteCount < numberToSend; deleteCount++) {\n          outQueue.shift();\n        }\n        if (useLocalStorage) {\n          attemptWriteLocalStorage(queueName, JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize)));\n        }\n        executeQueue();\n      };\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 400) {\n          clearTimeout(xhrTimeout);\n          onPostSuccess(numberToSend);\n        } else if (xhr.readyState === 4 && xhr.status >= 400) {\n          clearTimeout(xhrTimeout);\n          executingQueue = false;\n        }\n      };\n\n      if (!postable(outQueue)) {\n        // If not postable then it's a GET so just send it\n        xhr.send();\n      } else {\n        let batch = outQueue.slice(0, numberToSend);\n\n        if (batch.length > 0) {\n          let beaconStatus = false;\n\n          const eventBatch = batch.map(function (x) {\n            return x.evt;\n          });\n\n          if (useBeacon) {\n            const blob = new Blob([encloseInPayloadDataEnvelope(attachStmToEvent(eventBatch))], {\n              type: 'application/json',\n            });\n            try {\n              beaconStatus = navigator.sendBeacon(url, blob);\n            } catch (error) {\n              beaconStatus = false;\n            }\n          }\n\n          // When beaconStatus is true, we can't _guarantee_ that it was successful (beacon queues asynchronously)\n          // but the browser has taken it out of our hands, so we want to flush the queue assuming it will do its job\n          if (beaconStatus === true) {\n            onPostSuccess(numberToSend);\n          } else {\n            xhr.send(encloseInPayloadDataEnvelope(attachStmToEvent(eventBatch)));\n          }\n        }\n      }\n    } else if (!anonymousTracking && !postable(outQueue)) {\n      // We can't send with this technique if anonymous tracking is on as we can't attach the header\n      let image = new Image(1, 1),\n        loading = true;\n\n      image.onload = function () {\n        if (!loading) return;\n        loading = false;\n        outQueue.shift();\n        if (useLocalStorage) {\n          attemptWriteLocalStorage(queueName, JSON.stringify(outQueue.slice(0, maxLocalStorageQueueSize)));\n        }\n        executeQueue();\n      };\n\n      image.onerror = function () {\n        if (!loading) return;\n        loading = false;\n        executingQueue = false;\n      };\n\n      image.src = createGetUrl(outQueue[0]);\n\n      setTimeout(function () {\n        if (loading && executingQueue) {\n          loading = false;\n          executeQueue();\n        }\n      }, connectionTimeout);\n    } else {\n      executingQueue = false;\n    }\n  }\n\n  /**\n   * Open an XMLHttpRequest for a given endpoint with the correct credentials and header\n   *\n   * @param string - url The destination URL\n   * @return object The XMLHttpRequest\n   */\n  function initializeXMLHttpRequest(url: string, post: boolean, sync: boolean) {\n    const xhr = new XMLHttpRequest();\n    if (post) {\n      xhr.open('POST', url, !sync);\n      xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');\n    } else {\n      xhr.open('GET', url, !sync);\n    }\n    xhr.withCredentials = true;\n    if (anonymousTracking) {\n      xhr.setRequestHeader('SP-Anonymous', '*');\n    }\n    return xhr;\n  }\n\n  /**\n   * Enclose an array of events in a self-describing payload_data JSON string\n   *\n   * @param array - events Batch of events\n   * @return string payload_data self-describing JSON\n   */\n  function encloseInPayloadDataEnvelope(events: Array<Record<string, unknown>>) {\n    return JSON.stringify({\n      schema: 'iglu:com.snowplowanalytics.snowplow/payload_data/jsonschema/1-0-4',\n      data: events,\n    });\n  }\n\n  /**\n   * Attaches the STM field to outbound POST events.\n   *\n   * @param events - the events to attach the STM to\n   */\n  function attachStmToEvent(events: Array<Record<string, unknown>>) {\n    const stm = new Date().getTime().toString();\n    for (let i = 0; i < events.length; i++) {\n      events[i]['stm'] = stm;\n    }\n    return events;\n  }\n\n  /**\n   * Creates the full URL for sending the GET request. Will append `stm` if enabled\n   *\n   * @param nextRequest - the query string of the next request\n   */\n  function createGetUrl(nextRequest: string) {\n    if (useStm) {\n      return configCollectorUrl + nextRequest.replace('?', '?stm=' + new Date().getTime() + '&');\n    }\n\n    return configCollectorUrl + nextRequest;\n  }\n\n  return {\n    enqueueRequest: enqueueRequest,\n    executeQueue: () => {\n      if (!executingQueue) {\n        executeQueue();\n      }\n    },\n    setUseLocalStorage: (localStorage: boolean) => {\n      useLocalStorage = localStorage;\n    },\n    setAnonymousTracking: (anonymous: boolean) => {\n      anonymousTracking = anonymous;\n    },\n    setCollectorUrl: (url: string) => {\n      configCollectorUrl = url + path;\n    },\n    setBufferSize: (newBufferSize: number) => {\n      bufferSize = newBufferSize;\n    },\n  };\n\n  function hasWebKitBeaconBug(useragent: string) {\n    return (\n      isIosVersionLessThanOrEqualTo(13, useragent) ||\n      (isMacosxVersionLessThanOrEqualTo(10, 15, useragent) && isSafari(useragent))\n    );\n\n    function isIosVersionLessThanOrEqualTo(major: number, useragent: string) {\n      const match = useragent.match('(iP.+; CPU .*OS (d+)[_d]*.*) AppleWebKit/');\n      if (match && match.length) {\n        return parseInt(match[0]) <= major;\n      }\n      return false;\n    }\n\n    function isMacosxVersionLessThanOrEqualTo(major: number, minor: number, useragent: string) {\n      const match = useragent.match('(Macintosh;.*Mac OS X (d+)_(d+)[_d]*.*) AppleWebKit/');\n      if (match && match.length) {\n        return parseInt(match[0]) <= major || (parseInt(match[0]) === major && parseInt(match[1]) <= minor);\n      }\n      return false;\n    }\n\n    function isSafari(useragent: string) {\n      return useragent.match('Version/.* Safari/') && !isChromiumBased(useragent);\n    }\n\n    function isChromiumBased(useragent: string) {\n      return useragent.match('Chrom(e|ium)');\n    }\n  }\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { fromQuerystring, getHostName } from './helpers';\n\n/*\n * Extract parameter from URL\n */\nfunction getParameter(url: string, name: string) {\n  // scheme : // [username [: password] @] hostname [: port] [/ [path] [? query] [# fragment]]\n  var e = new RegExp('^(?:https?|ftp)(?::/*(?:[^?]+))([?][^#]+)'),\n    matches = e.exec(url);\n\n  if (matches && matches?.length > 1) {\n    return fromQuerystring(name, matches[1]);\n  }\n  return null;\n}\n\n/*\n * Fix-up URL when page rendered from search engine cache or translated page.\n */\nexport function fixupUrl(hostName: string, href: string, referrer: string) {\n  if (hostName === 'translate.googleusercontent.com') {\n    // Google\n    if (referrer === '') {\n      referrer = href;\n    }\n    href = getParameter(href, 'u') ?? '';\n    hostName = getHostName(href);\n  } else if (\n    hostName === 'cc.bingj.com' || // Bing & Yahoo\n    hostName === 'webcache.googleusercontent.com' // Google\n  ) {\n    href = document.links[0].href;\n    hostName = getHostName(href);\n  }\n  return [hostName, href, referrer];\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport {\n  trackerCore,\n  buildPagePing,\n  buildPageView,\n  CommonEventProperties,\n  PayloadBuilder,\n  SelfDescribingJson,\n  LOG,\n} from '@snowplow/tracker-core';\nimport hash from 'sha1';\nimport { v4 as uuid } from 'uuid';\nimport { detectDocumentSize, detectViewport } from '../detectors';\nimport {\n  decorateQuerystring,\n  findRootDomain,\n  fixupDomain,\n  getReferrer,\n  addEventListener,\n  getHostName,\n  cookie,\n  attemptGetLocalStorage,\n  attemptWriteLocalStorage,\n  attemptDeleteLocalStorage,\n  deleteCookie,\n  fixupTitle,\n  fromQuerystring,\n  isInteger,\n} from '../helpers';\nimport { OutQueueManager } from './out_queue';\nimport { fixupUrl } from '../proxies';\nimport { SharedState } from '../state';\nimport {\n  PageViewEvent,\n  ActivityCallback,\n  ActivityCallbackData,\n  TrackerConfiguration,\n  BrowserTracker,\n  ActivityTrackingConfiguration,\n  ActivityTrackingConfigurationCallback,\n  DisableAnonymousTrackingConfiguration,\n  EnableAnonymousTrackingConfiguration,\n  FlushBufferConfiguration,\n  BrowserPluginConfiguration,\n  ClearUserDataConfiguration,\n} from './types';\n\n/** Repesents an instance of an activity tracking configuration */\ntype ActivityConfig = {\n  /** The callback to fire based on heart beat */\n  callback: ActivityCallback;\n  /** The minimum time that must have elapsed before first heartbeat */\n  configMinimumVisitLength: number;\n  /** The interval at which the callback will be fired */\n  configHeartBeatTimer: number;\n  /** The setInterval identifier */\n  activityInterval?: number;\n};\n\n/** The configurations for the two types of Activity Tracking */\ntype ActivityConfigurations = {\n  /** The configuration for enableActivityTrackingCallback */\n  callback?: ActivityConfig;\n  /** The configuration for enableActivityTracking */\n  pagePing?: ActivityConfig;\n};\n\n/** The configuration for if either activity tracking system is enable */\ntype ActivityTrackingConfig = {\n  /** Tracks if activity tracking is enabled */\n  enabled: boolean;\n  /** Tracks if activity tracking hooks have been installed */\n  installed: boolean;\n  /** Stores the configuration for each type of activity tracking */\n  configurations: ActivityConfigurations;\n};\n\n/**\n * The Snowplow Tracker\n *\n * @param trackerId - The unique identifier of the tracker\n * @param namespace - The namespace of the tracker object\n * @param version - The current version of the JavaScript Tracker\n * @param endpoint - The collector endpoint to send events to, with or without protocol\n * @param sharedState - An object containing state which is shared across tracker instances\n * @param trackerConfiguration - Dictionary of configuration options\n */\nexport function Tracker(\n  trackerId: string,\n  namespace: string,\n  version: string,\n  endpoint: string,\n  sharedState: SharedState,\n  trackerConfiguration: TrackerConfiguration = {}\n): BrowserTracker {\n  const newTracker = (\n    trackerId: string,\n    namespace: string,\n    version: string,\n    endpoint: string,\n    state: SharedState,\n    trackerConfiguration: TrackerConfiguration\n  ) => {\n    /************************************************************\n     * Private members\n     ************************************************************/\n\n    //use POST if eventMethod isn't present on the newTrackerConfiguration\n    trackerConfiguration.eventMethod = trackerConfiguration.eventMethod ?? 'post';\n\n    const getStateStorageStrategy = (config: TrackerConfiguration) =>\n        config.stateStorageStrategy ?? 'cookieAndLocalStorage',\n      getAnonymousSessionTracking = (config: TrackerConfiguration) => {\n        if (typeof config.anonymousTracking === 'boolean') {\n          return false;\n        }\n        return config.anonymousTracking?.withSessionTracking === true ?? false;\n      },\n      getAnonymousServerTracking = (config: TrackerConfiguration) => {\n        if (typeof config.anonymousTracking === 'boolean') {\n          return false;\n        }\n        return config.anonymousTracking?.withServerAnonymisation === true ?? false;\n      },\n      getAnonymousTracking = (config: TrackerConfiguration) => !!config.anonymousTracking;\n\n    // Get all injected plugins\n    trackerConfiguration.plugins = trackerConfiguration.plugins ?? [];\n    if (trackerConfiguration?.contexts?.webPage ?? true) {\n      trackerConfiguration.plugins.push(getWebPagePlugin()); // Defaults to including the Web Page context\n    }\n\n    let // Tracker core\n      core = trackerCore({\n        base64: trackerConfiguration.encodeBase64,\n        corePlugins: trackerConfiguration.plugins,\n        callback: function (payloadBuilder) {\n          addBrowserData(payloadBuilder);\n          sendRequest(payloadBuilder);\n        },\n      }),\n      // Aliases\n      browserLanguage = (navigator as any).userLanguage || navigator.language,\n      documentCharset = document.characterSet || document.charset,\n      // Current URL and Referrer URL\n      locationArray = fixupUrl(window.location.hostname, window.location.href, getReferrer()),\n      domainAlias = fixupDomain(locationArray[0]),\n      locationHrefAlias = locationArray[1],\n      configReferrerUrl = locationArray[2],\n      customReferrer: string,\n      // Platform defaults to web for this tracker\n      configPlatform = trackerConfiguration.platform ?? 'web',\n      // Snowplow collector URL\n      configCollectorUrl = asCollectorUrl(endpoint),\n      // Custom path for post requests (to get around adblockers)\n      configPostPath = trackerConfiguration.postPath ?? '/com.snowplowanalytics.snowplow/tp2',\n      // Site ID\n      configTrackerSiteId = trackerConfiguration.appId ?? '',\n      // Document URL\n      configCustomUrl: string,\n      // Document title\n      lastDocumentTitle = document.title,\n      // Custom title\n      lastConfigTitle: string | null | undefined,\n      // Controls whether activity tracking page ping event timers are reset on page view events\n      resetActivityTrackingOnPageView = trackerConfiguration.resetActivityTrackingOnPageView ?? true,\n      // Disallow hash tags in URL. TODO: Should this be set to true by default?\n      configDiscardHashTag: boolean,\n      // Disallow brace in URL.\n      configDiscardBrace: boolean,\n      // First-party cookie name prefix\n      configCookieNamePrefix = trackerConfiguration.cookieName ?? '_sp_',\n      // First-party cookie domain\n      // User agent defaults to origin hostname\n      configCookieDomain = trackerConfiguration.cookieDomain ?? undefined,\n      // First-party cookie path\n      // Default is user agent defined.\n      configCookiePath = '/',\n      // First-party cookie samesite attribute\n      configCookieSameSite = trackerConfiguration.cookieSameSite ?? 'None',\n      // First-party cookie secure attribute\n      configCookieSecure = trackerConfiguration.cookieSecure ?? true,\n      // Do Not Track browser feature\n      dnt = navigator.doNotTrack || (navigator as any).msDoNotTrack || window.doNotTrack,\n      // Do Not Track\n      configDoNotTrack =\n        typeof trackerConfiguration.respectDoNotTrack !== 'undefined'\n          ? trackerConfiguration.respectDoNotTrack && (dnt === 'yes' || dnt === '1')\n          : false,\n      // Opt out of cookie tracking\n      configOptOutCookie: string,\n      // Life of the visitor cookie (in seconds)\n      configVisitorCookieTimeout = trackerConfiguration.cookieLifetime ?? 63072000, // 2 years\n      // Life of the session cookie (in seconds)\n      configSessionCookieTimeout = trackerConfiguration.sessionCookieTimeout ?? 1800, // 30 minutes\n      // Allows tracking user session (using cookies or local storage), can only be used with anonymousTracking\n      configAnonymousSessionTracking = getAnonymousSessionTracking(trackerConfiguration),\n      // Will send a header to server to prevent returning cookie and capturing IP\n      configAnonymousServerTracking = getAnonymousServerTracking(trackerConfiguration),\n      // Sets tracker to work in anonymous mode without accessing client storage\n      configAnonymousTracking = getAnonymousTracking(trackerConfiguration),\n      // Strategy defining how to store the state: cookie, localStorage, cookieAndLocalStorage or none\n      configStateStorageStrategy = getStateStorageStrategy(trackerConfiguration),\n      // Last activity timestamp\n      lastActivityTime: number,\n      // The last time an event was fired on the page - used to invalidate session if cookies are disabled\n      lastEventTime = new Date().getTime(),\n      // How are we scrolling?\n      minXOffset: number,\n      maxXOffset: number,\n      minYOffset: number,\n      maxYOffset: number,\n      // Domain hash value\n      domainHash: string,\n      // Domain unique user ID\n      domainUserId: string,\n      // ID for the current session\n      memorizedSessionId: string,\n      // Index for the current session - kept in memory in case cookies are disabled\n      memorizedVisitCount = 1,\n      // Business-defined unique user ID\n      businessUserId: string | null,\n      // Manager for local storage queue\n      outQueue = OutQueueManager(\n        trackerId,\n        state,\n        configStateStorageStrategy == 'localStorage' || configStateStorageStrategy == 'cookieAndLocalStorage',\n        trackerConfiguration.eventMethod,\n        configPostPath,\n        trackerConfiguration.bufferSize ?? 1,\n        trackerConfiguration.maxPostBytes ?? 40000,\n        trackerConfiguration.useStm ?? true,\n        trackerConfiguration.maxLocalStorageQueueSize ?? 1000,\n        trackerConfiguration.connectionTimeout ?? 5000,\n        configAnonymousServerTracking\n      ),\n      // Whether pageViewId should be regenerated after each trackPageView. Affect web_page context\n      preservePageViewId = false,\n      // Whether first trackPageView was fired and pageViewId should not be changed anymore until reload\n      pageViewSent = false,\n      // Activity tracking config for callback and pacge ping variants\n      activityTrackingConfig: ActivityTrackingConfig = {\n        enabled: false,\n        installed: false, // Guard against installing the activity tracker more than once per Tracker instance\n        configurations: {},\n      };\n\n    if (trackerConfiguration.hasOwnProperty('discoverRootDomain') && trackerConfiguration.discoverRootDomain) {\n      configCookieDomain = findRootDomain(configCookieSameSite, configCookieSecure);\n    }\n\n    // Set up unchanging name-value pairs\n    core.setTrackerVersion(version);\n    core.setTrackerNamespace(namespace);\n    core.setAppId(configTrackerSiteId);\n    core.setPlatform(configPlatform);\n    core.addPayloadPair('cookie', navigator.cookieEnabled ? '1' : '0');\n    core.addPayloadPair('cs', documentCharset);\n    core.addPayloadPair('lang', browserLanguage);\n    core.addPayloadPair('res', screen.width + 'x' + screen.height);\n    core.addPayloadPair('cd', screen.colorDepth);\n\n    /*\n     * Initialize tracker\n     */\n    updateDomainHash();\n\n    initializeIdsAndCookies();\n\n    if (trackerConfiguration.crossDomainLinker) {\n      decorateLinks(trackerConfiguration.crossDomainLinker);\n    }\n\n    /**\n     * Recalculate the domain, URL, and referrer\n     */\n    function refreshUrl() {\n      locationArray = fixupUrl(window.location.hostname, window.location.href, getReferrer());\n\n      // If this is a single-page app and the page URL has changed, then:\n      //   - if the new URL's querystring contains a \"refer(r)er\" parameter, use it as the referrer\n      //   - otherwise use the old URL as the referer\n      if (locationArray[1] !== locationHrefAlias) {\n        configReferrerUrl = getReferrer(locationHrefAlias);\n      }\n\n      domainAlias = fixupDomain(locationArray[0]);\n      locationHrefAlias = locationArray[1];\n    }\n\n    /**\n     * Decorate the querystring of a single link\n     *\n     * @param event - e The event targeting the link\n     */\n    function linkDecorationHandler(evt: Event) {\n      var timestamp = new Date().getTime();\n      let elt = evt.target as HTMLAnchorElement | HTMLAreaElement | null;\n      if (elt?.href) {\n        elt.href = decorateQuerystring(elt.href, '_sp', domainUserId + '.' + timestamp);\n      }\n    }\n\n    /**\n     * Enable querystring decoration for links pasing a filter\n     * Whenever such a link is clicked on or navigated to via the keyboard,\n     * add \"_sp={{duid}}.{{timestamp}}\" to its querystring\n     *\n     * @param crossDomainLinker - Function used to determine which links to decorate\n     */\n    function decorateLinks(crossDomainLinker: (elt: HTMLAnchorElement | HTMLAreaElement) => boolean) {\n      for (var i = 0; i < document.links.length; i++) {\n        var elt = document.links[i];\n        if (!(elt as any).spDecorationEnabled && crossDomainLinker(elt)) {\n          addEventListener(elt, 'click', linkDecorationHandler, true);\n          addEventListener(elt, 'mousedown', linkDecorationHandler, true);\n\n          // Don't add event listeners more than once\n          (elt as any).spDecorationEnabled = true;\n        }\n      }\n    }\n\n    /*\n     * Removes hash tag from the URL\n     *\n     * URLs are purified before being recorded in the cookie,\n     * or before being sent as GET parameters\n     */\n    function purify(url: string) {\n      var targetPattern;\n\n      if (configDiscardHashTag) {\n        targetPattern = new RegExp('#.*');\n        url = url.replace(targetPattern, '');\n      }\n\n      if (configDiscardBrace) {\n        targetPattern = new RegExp('[{}]', 'g');\n        url = url.replace(targetPattern, '');\n      }\n      return url;\n    }\n\n    /*\n     * Extract scheme/protocol from URL\n     */\n    function getProtocolScheme(url: string) {\n      var e = new RegExp('^([a-z]+):'),\n        matches = e.exec(url);\n\n      return matches ? matches[1] : null;\n    }\n\n    /*\n     * Resolve relative reference\n     *\n     * Note: not as described in rfc3986 section 5.2\n     */\n    function resolveRelativeReference(baseUrl: string, url: string) {\n      var protocol = getProtocolScheme(url),\n        i;\n\n      if (protocol) {\n        return url;\n      }\n\n      if (url.slice(0, 1) === '/') {\n        return getProtocolScheme(baseUrl) + '://' + getHostName(baseUrl) + url;\n      }\n\n      baseUrl = purify(baseUrl);\n      if ((i = baseUrl.indexOf('?')) >= 0) {\n        baseUrl = baseUrl.slice(0, i);\n      }\n      if ((i = baseUrl.lastIndexOf('/')) !== baseUrl.length - 1) {\n        baseUrl = baseUrl.slice(0, i + 1);\n      }\n\n      return baseUrl + url;\n    }\n\n    /*\n     * Send request\n     */\n    function sendRequest(request: PayloadBuilder) {\n      // Set to true if Opt-out cookie is defined\n      var toOptoutByCookie;\n      if (configOptOutCookie) {\n        toOptoutByCookie = !!cookie(configOptOutCookie);\n      } else {\n        toOptoutByCookie = false;\n      }\n\n      if (!(configDoNotTrack || toOptoutByCookie)) {\n        outQueue.enqueueRequest(request.build(), configCollectorUrl);\n      }\n    }\n\n    /*\n     * Get cookie name with prefix and domain hash\n     */\n    function getSnowplowCookieName(baseName: string) {\n      return configCookieNamePrefix + baseName + '.' + domainHash;\n    }\n\n    /*\n     * Cookie getter.\n     */\n    function getSnowplowCookieValue(cookieName: string) {\n      var fullName = getSnowplowCookieName(cookieName);\n      if (configStateStorageStrategy == 'localStorage') {\n        return attemptGetLocalStorage(fullName);\n      } else if (configStateStorageStrategy == 'cookie' || configStateStorageStrategy == 'cookieAndLocalStorage') {\n        return cookie(fullName);\n      }\n      return undefined;\n    }\n\n    /*\n     * Update domain hash\n     */\n    function updateDomainHash() {\n      refreshUrl();\n      domainHash = hash((configCookieDomain || domainAlias) + (configCookiePath || '/')).slice(0, 4); // 4 hexits = 16 bits\n    }\n\n    /*\n     * Process all \"activity\" events.\n     * For performance, this function must have low overhead.\n     */\n    function activityHandler() {\n      var now = new Date();\n      lastActivityTime = now.getTime();\n    }\n\n    /*\n     * Process all \"scroll\" events.\n     */\n    function scrollHandler() {\n      updateMaxScrolls();\n      activityHandler();\n    }\n\n    /*\n     * Returns [pageXOffset, pageYOffset]\n     */\n    function getPageOffsets() {\n      const documentElement = document.documentElement;\n      if (documentElement) {\n        return [documentElement.scrollLeft || window.pageXOffset, documentElement.scrollTop || window.pageYOffset];\n      }\n\n      return [0, 0];\n    }\n\n    /*\n     * Quick initialization/reset of max scroll levels\n     */\n    function resetMaxScrolls() {\n      const offsets = getPageOffsets();\n\n      const x = offsets[0];\n      minXOffset = x;\n      maxXOffset = x;\n\n      const y = offsets[1];\n      minYOffset = y;\n      maxYOffset = y;\n    }\n\n    /*\n     * Check the max scroll levels, updating as necessary\n     */\n    function updateMaxScrolls() {\n      const offsets = getPageOffsets();\n\n      const x = offsets[0];\n      if (x < minXOffset) {\n        minXOffset = x;\n      } else if (x > maxXOffset) {\n        maxXOffset = x;\n      }\n\n      const y = offsets[1];\n      if (y < minYOffset) {\n        minYOffset = y;\n      } else if (y > maxYOffset) {\n        maxYOffset = y;\n      }\n    }\n\n    /*\n     * Prevents offsets from being decimal or NaN\n     * See https://github.com/snowplow/snowplow-javascript-tracker/issues/324\n     */\n    function cleanOffset(offset: number) {\n      return Math.round(offset);\n    }\n\n    /*\n     * Sets or renews the session cookie\n     */\n    function setSessionCookie() {\n      var cookieName = getSnowplowCookieName('ses');\n      var cookieValue = '*';\n      setCookie(cookieName, cookieValue, configSessionCookieTimeout);\n    }\n\n    /*\n     * Sets the Visitor ID cookie: either the first time loadDomainUserIdCookie is called\n     * or when there is a new visit or a new page view\n     */\n    function setDomainUserIdCookie(\n      domainUserId: string,\n      createTs: number,\n      visitCount: number,\n      nowTs: number,\n      lastVisitTs: number,\n      sessionId: string\n    ) {\n      var cookieName = getSnowplowCookieName('id');\n      var cookieValue =\n        domainUserId + '.' + createTs + '.' + visitCount + '.' + nowTs + '.' + lastVisitTs + '.' + sessionId;\n      setCookie(cookieName, cookieValue, configVisitorCookieTimeout);\n    }\n\n    /*\n     * no-op if anonymousTracking enabled, will still set cookies if anonymousSessionTracking is enabled\n     * Sets a cookie based on the storage strategy:\n     * - if 'localStorage': attemps to write to local storage\n     * - if 'cookie' or 'cookieAndLocalStorage': writes to cookies\n     * - otherwise: no-op\n     */\n    function setCookie(name: string, value: string, timeout: number) {\n      if (configAnonymousTracking && !configAnonymousSessionTracking) {\n        return;\n      }\n\n      if (configStateStorageStrategy == 'localStorage') {\n        attemptWriteLocalStorage(name, value, timeout);\n      } else if (configStateStorageStrategy == 'cookie' || configStateStorageStrategy == 'cookieAndLocalStorage') {\n        cookie(name, value, timeout, configCookiePath, configCookieDomain, configCookieSameSite, configCookieSecure);\n      }\n    }\n\n    /**\n     * Clears all cookie and local storage for id and ses values\n     */\n    function clearUserDataAndCookies(configuration?: ClearUserDataConfiguration) {\n      const idname = getSnowplowCookieName('id');\n      const sesname = getSnowplowCookieName('ses');\n      attemptDeleteLocalStorage(idname);\n      attemptDeleteLocalStorage(sesname);\n      deleteCookie(idname, configCookieDomain, configCookieSameSite, configCookieSecure);\n      deleteCookie(sesname, configCookieDomain, configCookieSameSite, configCookieSecure);\n      if (!configuration?.preserveSession) {\n        memorizedSessionId = uuid();\n        memorizedVisitCount = 0;\n      }\n      if (!configuration?.preserveUser) {\n        domainUserId = uuid();\n        businessUserId = null;\n      }\n    }\n\n    /**\n     * Toggle Anaonymous Tracking\n     */\n    function toggleAnonymousTracking(\n      configuration?: EnableAnonymousTrackingConfiguration | DisableAnonymousTrackingConfiguration\n    ) {\n      if (configuration && configuration.stateStorageStrategy) {\n        trackerConfiguration.stateStorageStrategy = configuration.stateStorageStrategy;\n        configStateStorageStrategy = getStateStorageStrategy(trackerConfiguration);\n      }\n\n      configAnonymousTracking = getAnonymousTracking(trackerConfiguration);\n      configAnonymousSessionTracking = getAnonymousSessionTracking(trackerConfiguration);\n      configAnonymousServerTracking = getAnonymousServerTracking(trackerConfiguration);\n\n      outQueue.setUseLocalStorage(\n        configStateStorageStrategy == 'localStorage' || configStateStorageStrategy == 'cookieAndLocalStorage'\n      );\n      outQueue.setAnonymousTracking(configAnonymousServerTracking);\n    }\n\n    /*\n     * Load the domain user ID and the session ID\n     * Set the cookies (if cookies are enabled)\n     */\n    function initializeIdsAndCookies() {\n      if (configAnonymousTracking && !configAnonymousSessionTracking) {\n        return;\n      }\n\n      var sesCookieSet = configStateStorageStrategy != 'none' && !!getSnowplowCookieValue('ses');\n      var idCookieComponents = loadDomainUserIdCookie();\n\n      if (idCookieComponents[1]) {\n        domainUserId = idCookieComponents[1] as string;\n      } else if (!configAnonymousTracking) {\n        domainUserId = uuid();\n        idCookieComponents[1] = domainUserId;\n      } else {\n        domainUserId = '';\n        idCookieComponents[1] = domainUserId;\n      }\n\n      memorizedSessionId = idCookieComponents[6] as string;\n\n      if (!sesCookieSet) {\n        // Increment the session ID\n        (idCookieComponents[3] as number)++;\n        // Create a new sessionId\n        memorizedSessionId = uuid();\n        idCookieComponents[6] = memorizedSessionId;\n        // Set lastVisitTs to currentVisitTs\n        idCookieComponents[5] = idCookieComponents[4];\n      }\n\n      if (configStateStorageStrategy != 'none') {\n        setSessionCookie();\n        // Update currentVisitTs\n        idCookieComponents[4] = Math.round(new Date().getTime() / 1000);\n        idCookieComponents.shift();\n        setDomainUserIdCookie.apply(null, idCookieComponents as any); // TODO: Remove any\n      }\n    }\n\n    /*\n     * Load visitor ID cookie\n     */\n    function loadDomainUserIdCookie() {\n      if (configStateStorageStrategy == 'none') {\n        return [];\n      }\n      var now = new Date(),\n        nowTs = Math.round(now.getTime() / 1000),\n        id = getSnowplowCookieValue('id'),\n        tmpContainer;\n\n      if (id) {\n        tmpContainer = id.split('.');\n        // cookies enabled\n        tmpContainer.unshift('0');\n      } else {\n        tmpContainer = [\n          // cookies disabled\n          '1',\n          // Domain user ID\n          domainUserId,\n          // Creation timestamp - seconds since Unix epoch\n          nowTs,\n          // visitCount - 0 = no previous visit\n          0,\n          // Current visit timestamp\n          nowTs,\n          // Last visit timestamp - blank meaning no previous visit\n          '',\n        ];\n      }\n\n      if (!tmpContainer[6]) {\n        // session id\n        tmpContainer[6] = uuid();\n      }\n\n      return tmpContainer;\n    }\n\n    /*\n     * Attaches common web fields to every request (resolution, url, referrer, etc.)\n     * Also sets the required cookies.\n     */\n    function addBrowserData(payloadBuilder: PayloadBuilder) {\n      const anonymizeOr = (value: string | number | null) => (configAnonymousTracking ? null : value);\n      const anonymizeSessionOr = (value: string | number) =>\n        configAnonymousSessionTracking ? value : anonymizeOr(value);\n\n      var nowTs = Math.round(new Date().getTime() / 1000),\n        ses = getSnowplowCookieValue('ses'),\n        id = loadDomainUserIdCookie(),\n        cookiesDisabled = id[0],\n        _domainUserId = id[1] as string, // We could use the global (domainUserId) but this is better etiquette\n        createTs = id[2] as number,\n        visitCount = id[3] as number,\n        currentVisitTs = id[4] as number,\n        lastVisitTs = id[5] as number,\n        sessionIdFromCookie = id[6] as string;\n\n      var toOptoutByCookie;\n      if (configOptOutCookie) {\n        toOptoutByCookie = !!cookie(configOptOutCookie);\n      } else {\n        toOptoutByCookie = false;\n      }\n\n      if (configDoNotTrack || toOptoutByCookie) {\n        clearUserDataAndCookies();\n        return;\n      }\n\n      // If cookies are enabled, base visit count and session ID on the cookies\n      if (cookiesDisabled === '0') {\n        memorizedSessionId = sessionIdFromCookie as string;\n\n        // New session?\n        if (!ses && configStateStorageStrategy != 'none') {\n          // New session (aka new visit)\n          (visitCount as number)++;\n          // Update the last visit timestamp\n          lastVisitTs = currentVisitTs;\n          // Regenerate the session ID\n          memorizedSessionId = uuid();\n        }\n\n        memorizedVisitCount = visitCount as number;\n      } else if (new Date().getTime() - lastEventTime > configSessionCookieTimeout * 1000) {\n        memorizedSessionId = uuid();\n        memorizedVisitCount++;\n      }\n\n      payloadBuilder.add('vp', detectViewport());\n      payloadBuilder.add('ds', detectDocumentSize());\n      payloadBuilder.add('vid', anonymizeSessionOr(memorizedVisitCount));\n      payloadBuilder.add('sid', anonymizeSessionOr(memorizedSessionId));\n      payloadBuilder.add('duid', anonymizeOr(_domainUserId)); // Set to our local variable\n      payloadBuilder.add('uid', anonymizeOr(businessUserId));\n\n      refreshUrl();\n\n      payloadBuilder.add('refr', purify(customReferrer || configReferrerUrl));\n\n      // Add the page URL last as it may take us over the IE limit (and we don't always need it)\n      payloadBuilder.add('url', purify(configCustomUrl || locationHrefAlias));\n\n      // Update cookies\n      if (configStateStorageStrategy != 'none') {\n        setDomainUserIdCookie(_domainUserId, createTs, memorizedVisitCount, nowTs, lastVisitTs, memorizedSessionId);\n        setSessionCookie();\n      }\n\n      lastEventTime = new Date().getTime();\n    }\n\n    /**\n     * Adds the protocol in front of our collector URL\n     *\n     * @param string - collectorUrl The collector URL with or without protocol\n     * @returns string collectorUrl The tracker URL with protocol\n     */\n    function asCollectorUrl(collectorUrl: string) {\n      if (collectorUrl.indexOf('http') === 0) {\n        return collectorUrl;\n      }\n\n      return ('https:' === document.location.protocol ? 'https' : 'http') + '://' + collectorUrl;\n    }\n\n    /**\n     * Initialize new `pageViewId` if it shouldn't be preserved.\n     * Should be called when `trackPageView` is invoked\n     */\n    function resetPageView() {\n      if (!preservePageViewId || state.pageViewId == null) {\n        state.pageViewId = uuid();\n      }\n    }\n\n    /**\n     * Safe function to get `pageViewId`.\n     * Generates it if it wasn't initialized by other tracker\n     */\n    function getPageViewId() {\n      if (state.pageViewId == null) {\n        state.pageViewId = uuid();\n      }\n      return state.pageViewId;\n    }\n\n    /**\n     * Put together a web page context with a unique UUID for the page view\n     *\n     * @returns web_page context\n     */\n    function getWebPagePlugin() {\n      return {\n        contexts: () => {\n          return [\n            {\n              schema: 'iglu:com.snowplowanalytics.snowplow/web_page/jsonschema/1-0-0',\n              data: {\n                id: getPageViewId(),\n              },\n            },\n          ];\n        },\n      };\n    }\n\n    /**\n     * Expires current session and starts a new session.\n     */\n    function newSession() {\n      // If cookies are enabled, base visit count and session ID on the cookies\n      var nowTs = Math.round(new Date().getTime() / 1000),\n        id = loadDomainUserIdCookie(),\n        cookiesDisabled = id[0],\n        _domainUserId = id[1] as string, // We could use the global (domainUserId) but this is better etiquette\n        createTs = id[2] as number,\n        visitCount = id[3] as number,\n        currentVisitTs = id[4] as number,\n        lastVisitTs = id[5] as number,\n        sessionIdFromCookie = id[6] as string;\n\n      // When cookies are enabled\n      if (cookiesDisabled === '0') {\n        memorizedSessionId = sessionIdFromCookie;\n\n        // When cookie/local storage is enabled - make a new session\n        if (configStateStorageStrategy != 'none') {\n          // New session (aka new visit)\n          visitCount++;\n          // Update the last visit timestamp\n          lastVisitTs = currentVisitTs;\n          // Regenerate the session ID\n          memorizedSessionId = uuid();\n        }\n\n        memorizedVisitCount = visitCount;\n\n        // Create a new session cookie\n        setSessionCookie();\n      } else {\n        memorizedSessionId = uuid();\n        memorizedVisitCount++;\n      }\n\n      // Update cookies\n      if (configStateStorageStrategy != 'none') {\n        setDomainUserIdCookie(_domainUserId, createTs, memorizedVisitCount, nowTs, lastVisitTs, memorizedSessionId);\n        setSessionCookie();\n      }\n\n      lastEventTime = new Date().getTime();\n    }\n\n    /**\n     * Combine an array of unchanging contexts with the result of a context-creating function\n     *\n     * @param staticContexts - Array of custom contexts\n     * @param contextCallback - Function returning an array of contexts\n     */\n    function finalizeContexts(\n      staticContexts?: Array<SelfDescribingJson> | null,\n      contextCallback?: (() => Array<SelfDescribingJson>) | null\n    ) {\n      return (staticContexts || []).concat(contextCallback ? contextCallback() : []);\n    }\n\n    function logPageView({ title, context, timestamp, contextCallback }: PageViewEvent & CommonEventProperties) {\n      refreshUrl();\n      if (pageViewSent) {\n        // Do not reset pageViewId if previous events were not page_view\n        resetPageView();\n      }\n      pageViewSent = true;\n\n      // So we know what document.title was at the time of trackPageView\n      lastDocumentTitle = document.title;\n      lastConfigTitle = title;\n\n      // Fixup page title\n      var pageTitle = fixupTitle(lastConfigTitle || lastDocumentTitle);\n\n      // Log page view\n      core.track(\n        buildPageView({\n          pageUrl: purify(configCustomUrl || locationHrefAlias),\n          pageTitle,\n          referrer: purify(customReferrer || configReferrerUrl),\n        }),\n        finalizeContexts(context, contextCallback),\n        timestamp\n      );\n\n      // Send ping (to log that user has stayed on page)\n      var now = new Date();\n      var installingActivityTracking = false;\n\n      if (activityTrackingConfig.enabled && !activityTrackingConfig.installed) {\n        activityTrackingConfig.installed = true;\n        installingActivityTracking = true;\n\n        // Add mousewheel event handler, detect passive event listeners for performance\n        var detectPassiveEvents: { update: () => void; hasSupport?: boolean } = {\n          update: function update() {\n            if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n              var passive = false;\n              var options = Object.defineProperty({}, 'passive', {\n                get: function get() {\n                  passive = true;\n                },\n              });\n              // note: have to set and remove a no-op listener instead of null\n              // (which was used previously), becasue Edge v15 throws an error\n              // when providing a null callback.\n              // https://github.com/rafrex/detect-passive-events/pull/3\n              var noop = function noop() {};\n              window.addEventListener('testPassiveEventSupport', noop, options);\n              window.removeEventListener('testPassiveEventSupport', noop, options);\n              detectPassiveEvents.hasSupport = passive;\n            }\n          },\n        };\n        detectPassiveEvents.update();\n\n        // Detect available wheel event\n        var wheelEvent =\n          'onwheel' in document.createElement('div')\n            ? 'wheel' // Modern browsers support \"wheel\"\n            : (document as any).onmousewheel !== undefined\n            ? 'mousewheel' // Webkit and IE support at least \"mousewheel\"\n            : 'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox\n\n        if (Object.prototype.hasOwnProperty.call(detectPassiveEvents, 'hasSupport')) {\n          addEventListener(document, wheelEvent, activityHandler, { passive: true });\n        } else {\n          addEventListener(document, wheelEvent, activityHandler);\n        }\n\n        // Capture our initial scroll points\n        resetMaxScrolls();\n\n        // Add event handlers; cross-browser compatibility here varies significantly\n        // @see http://quirksmode.org/dom/events\n        const documentHandlers = ['click', 'mouseup', 'mousedown', 'mousemove', 'keypress', 'keydown', 'keyup'];\n        const windowHandlers = ['resize', 'focus', 'blur'];\n        const listener = (_: Document | Window, handler = activityHandler) => (ev: string) =>\n          addEventListener(document, ev, handler);\n\n        documentHandlers.forEach(listener(document));\n        windowHandlers.forEach(listener(window));\n        listener(window, scrollHandler)('scroll');\n      }\n\n      if (activityTrackingConfig.enabled && (resetActivityTrackingOnPageView || installingActivityTracking)) {\n        // Periodic check for activity.\n        lastActivityTime = now.getTime();\n\n        let key: keyof ActivityConfigurations;\n        for (key in activityTrackingConfig.configurations) {\n          const config = activityTrackingConfig.configurations[key];\n          if (config) {\n            //Clear page ping heartbeat on new page view\n            window.clearInterval(config.activityInterval);\n\n            activityInterval(config, context, contextCallback);\n          }\n        }\n      }\n    }\n\n    function activityInterval(\n      config: ActivityConfig,\n      context?: Array<SelfDescribingJson> | null,\n      contextCallback?: (() => Array<SelfDescribingJson>) | null\n    ) {\n      const executePagePing = (cb: ActivityCallback, c: Array<SelfDescribingJson>) => {\n        refreshUrl();\n        cb({ context: c, pageViewId: getPageViewId(), minXOffset, minYOffset, maxXOffset, maxYOffset });\n        resetMaxScrolls();\n      };\n\n      const timeout = () => {\n        var now = new Date();\n\n        // There was activity during the heart beat period;\n        // on average, this is going to overstate the visitDuration by configHeartBeatTimer/2\n        if (lastActivityTime + config.configMinimumVisitLength > now.getTime()) {\n          executePagePing(config.callback, finalizeContexts(context, contextCallback));\n        }\n\n        config.activityInterval = window.setInterval(heartbeat, config.configHeartBeatTimer);\n      };\n\n      const heartbeat = () => {\n        var now = new Date();\n\n        // There was activity during the heart beat period;\n        // on average, this is going to overstate the visitDuration by configHeartBeatTimer/2\n        if (lastActivityTime + config.configHeartBeatTimer > now.getTime()) {\n          executePagePing(config.callback, finalizeContexts(context, contextCallback));\n        }\n      };\n\n      if (config.configMinimumVisitLength != 0) {\n        config.activityInterval = window.setTimeout(timeout, config.configMinimumVisitLength);\n      } else {\n        config.activityInterval = window.setInterval(heartbeat, config.configHeartBeatTimer);\n      }\n    }\n\n    /**\n     * Configure the activity tracking and ensures integer values for min visit and heartbeat\n     */\n    function configureActivityTracking(\n      configuration: ActivityTrackingConfiguration & ActivityTrackingConfigurationCallback\n    ): ActivityConfig | undefined {\n      const { minimumVisitLength, heartbeatDelay, callback } = configuration;\n      if (isInteger(minimumVisitLength) && isInteger(heartbeatDelay)) {\n        return {\n          configMinimumVisitLength: minimumVisitLength * 1000,\n          configHeartBeatTimer: heartbeatDelay * 1000,\n          callback,\n        };\n      }\n\n      LOG.warn(\n        'Activity tracking not enabled, please provide integer values for minimumVisitLength and heartbeatDelay.'\n      );\n      return undefined;\n    }\n\n    /**\n     * Log that a user is still viewing a given page by sending a page ping.\n     * Not part of the public API - only called from logPageView() above.\n     */\n    function logPagePing({ context, minXOffset, minYOffset, maxXOffset, maxYOffset }: ActivityCallbackData) {\n      var newDocumentTitle = document.title;\n      if (newDocumentTitle !== lastDocumentTitle) {\n        lastDocumentTitle = newDocumentTitle;\n        lastConfigTitle = undefined;\n      }\n      core.track(\n        buildPagePing({\n          pageUrl: purify(configCustomUrl || locationHrefAlias),\n          pageTitle: fixupTitle(lastConfigTitle || lastDocumentTitle),\n          referrer: purify(customReferrer || configReferrerUrl),\n          minXOffset: cleanOffset(minXOffset),\n          maxXOffset: cleanOffset(maxXOffset),\n          minYOffset: cleanOffset(minYOffset),\n          maxYOffset: cleanOffset(maxYOffset),\n        }),\n        context\n      );\n    }\n\n    const apiMethods = {\n      getDomainSessionIndex: function () {\n        return memorizedVisitCount;\n      },\n\n      getPageViewId: function () {\n        return getPageViewId();\n      },\n\n      newSession: newSession,\n\n      getCookieName: function (basename: string) {\n        return getSnowplowCookieName(basename);\n      },\n\n      getUserId: function () {\n        return businessUserId;\n      },\n\n      getDomainUserId: function () {\n        return loadDomainUserIdCookie()[1];\n      },\n\n      getDomainUserInfo: function () {\n        return loadDomainUserIdCookie();\n      },\n\n      setReferrerUrl: function (url: string) {\n        customReferrer = url;\n      },\n\n      setCustomUrl: function (url: string) {\n        refreshUrl();\n        configCustomUrl = resolveRelativeReference(locationHrefAlias, url);\n      },\n\n      setDocumentTitle: function (title: string) {\n        // So we know what document.title was at the time of trackPageView\n        lastDocumentTitle = document.title;\n        lastConfigTitle = title;\n      },\n\n      discardHashTag: function (enableFilter: boolean) {\n        configDiscardHashTag = enableFilter;\n      },\n\n      discardBrace: function (enableFilter: boolean) {\n        configDiscardBrace = enableFilter;\n      },\n\n      setCookiePath: function (path: string) {\n        configCookiePath = path;\n        updateDomainHash();\n      },\n\n      setVisitorCookieTimeout: function (timeout: number) {\n        configVisitorCookieTimeout = timeout;\n      },\n\n      crossDomainLinker: function (crossDomainLinkerCriterion: (elt: HTMLAnchorElement | HTMLAreaElement) => boolean) {\n        decorateLinks(crossDomainLinkerCriterion);\n      },\n\n      enableActivityTracking: function (configuration: ActivityTrackingConfiguration) {\n        activityTrackingConfig.enabled = true;\n        activityTrackingConfig.configurations.pagePing = configureActivityTracking({\n          ...configuration,\n          callback: logPagePing,\n        });\n      },\n\n      enableActivityTrackingCallback: function (\n        configuration: ActivityTrackingConfiguration & ActivityTrackingConfigurationCallback\n      ) {\n        activityTrackingConfig.enabled = true;\n        activityTrackingConfig.configurations.callback = configureActivityTracking(configuration);\n      },\n\n      updatePageActivity: function () {\n        activityHandler();\n      },\n\n      setOptOutCookie: function (name: string) {\n        configOptOutCookie = name;\n      },\n\n      setUserId: function (userId: string) {\n        businessUserId = userId;\n      },\n\n      setUserIdFromLocation: function (querystringField: string) {\n        refreshUrl();\n        businessUserId = fromQuerystring(querystringField, locationHrefAlias);\n      },\n\n      setUserIdFromReferrer: function (querystringField: string) {\n        refreshUrl();\n        businessUserId = fromQuerystring(querystringField, configReferrerUrl);\n      },\n\n      setUserIdFromCookie: function (cookieName: string) {\n        businessUserId = cookie(cookieName);\n      },\n\n      setCollectorUrl: function (collectorUrl: string) {\n        configCollectorUrl = asCollectorUrl(collectorUrl);\n        outQueue.setCollectorUrl(configCollectorUrl);\n      },\n\n      setBufferSize: function (newBufferSize: number) {\n        outQueue.setBufferSize(newBufferSize);\n      },\n\n      flushBuffer: function (configuration: FlushBufferConfiguration = {}) {\n        outQueue.executeQueue();\n        if (configuration.newBufferSize) {\n          outQueue.setBufferSize(configuration.newBufferSize);\n        }\n      },\n\n      trackPageView: function (event: PageViewEvent & CommonEventProperties = {}) {\n        logPageView(event);\n      },\n\n      preservePageViewId: function () {\n        preservePageViewId = true;\n      },\n\n      disableAnonymousTracking: function (configuration?: DisableAnonymousTrackingConfiguration) {\n        trackerConfiguration.anonymousTracking = false;\n\n        toggleAnonymousTracking(configuration);\n\n        initializeIdsAndCookies();\n\n        outQueue.executeQueue(); // There might be some events in the queue we've been unable to send in anonymous mode\n      },\n\n      enableAnonymousTracking: function (configuration?: EnableAnonymousTrackingConfiguration) {\n        trackerConfiguration.anonymousTracking = (configuration && configuration?.options) || true;\n\n        toggleAnonymousTracking(configuration);\n\n        // Reset the page view, if not tracking the session, so can't stitch user into new events on the page view id\n        if (!configAnonymousSessionTracking) {\n          resetPageView();\n        }\n      },\n\n      clearUserData: clearUserDataAndCookies,\n    };\n\n    return {\n      ...apiMethods,\n      id: trackerId,\n      namespace,\n      core: core,\n      sharedState: state,\n    };\n  };\n\n  // Initialise the tracker\n  const partialTracker = newTracker(trackerId, namespace, version, endpoint, sharedState, trackerConfiguration),\n    tracker = {\n      ...partialTracker,\n      addPlugin: (configuration: BrowserPluginConfiguration) => {\n        tracker.core.addPlugin(configuration);\n        configuration.plugin.activateBrowserPlugin?.(tracker);\n      },\n    };\n\n  // Initialise each plugin with the tracker\n  trackerConfiguration.plugins?.forEach((p) => {\n    p.activateBrowserPlugin?.(tracker);\n  });\n\n  return tracker;\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { LOG } from '@snowplow/tracker-core';\nimport { SharedState } from './state';\nimport { Tracker } from './tracker';\nimport { BrowserTracker, TrackerConfiguration } from './tracker/types';\n\nconst namedTrackers: Record<string, BrowserTracker> = {};\n\n/**\n * Dispatch function to all specified trackers\n *\n * @param trackers - An optional list of trackers to send the event to, or will send to all trackers\n * @param fn - The function which will run against each tracker\n */\nexport function dispatchToTrackers(trackers: Array<string> | undefined, fn: (t: BrowserTracker) => void) {\n  try {\n    getTrackers(trackers ?? allTrackerNames()).forEach(fn);\n  } catch (ex) {\n    LOG.error('Function failed', ex);\n  }\n}\n\n/**\n * Dispatch function to all specified trackers from the supplied collection\n *\n * @param trackers - An optional list of trackers to send the event to, or will send to all trackers\n * @param trackerCollection - The collection which the trackers will be selected from\n * @param fn - The function which will run against each tracker\n */\nexport function dispatchToTrackersInCollection(\n  trackers: Array<string> | undefined,\n  trackerCollection: Record<string, BrowserTracker>,\n  fn: (t: BrowserTracker) => void\n) {\n  try {\n    getTrackersFromCollection(trackers ?? Object.keys(trackerCollection), trackerCollection).forEach(fn);\n  } catch (ex) {\n    LOG.error('Function failed', ex);\n  }\n}\n\n/**\n * Checks if a tracker has been created for a particular identifier\n * @param trackerId - The unique identifier of the tracker\n */\nexport function trackerExists(trackerId: string) {\n  return namedTrackers.hasOwnProperty(trackerId);\n}\n\n/**\n * Creates a Tracker and adds it to the internal collection\n * @param trackerId - The unique identifier of the tracker\n * @param namespace - The namespace of the tracker, tracked with each event as `tna`\n * @param version - The current version of the tracker library\n * @param endpoint - The endpoint to send events to\n * @param sharedState - The instance of shared state to use for this tracker\n * @param configuration - The configuration to use for this tracker instance\n */\nexport function addTracker(\n  trackerId: string,\n  namespace: string,\n  version: string,\n  endpoint: string,\n  sharedState: SharedState,\n  configuration?: TrackerConfiguration\n) {\n  if (!namedTrackers.hasOwnProperty(trackerId)) {\n    namedTrackers[trackerId] = Tracker(trackerId, namespace, version, endpoint, sharedState, configuration);\n    return namedTrackers[trackerId];\n  }\n  return null;\n}\n\n/**\n * Gets a single instance of the internal tracker object\n * @param trackerId - The unique identifier of the tracker\n * @returns The tracker instance, or null if not found\n */\nexport function getTracker(trackerId: string) {\n  if (namedTrackers.hasOwnProperty(trackerId)) {\n    return namedTrackers[trackerId];\n  }\n\n  LOG.warn(trackerId + ' not configured');\n  return null;\n}\n\n/**\n * Gets an array of tracker instances based on the list of identifiers\n * @param trackerIds - An array of unique identifiers of the trackers\n * @returns The tracker instances, or empty list if none found\n */\nexport function getTrackers(trackerIds: Array<string>): Array<BrowserTracker> {\n  return getTrackersFromCollection(trackerIds, namedTrackers);\n}\n\n/**\n * Gets all the trackers as a object, keyed by their unique identifiers\n */\nexport function allTrackers() {\n  return namedTrackers;\n}\n\n/**\n * Returns all the unique tracker identifiers\n */\nexport function allTrackerNames() {\n  return Object.keys(namedTrackers);\n}\n\nfunction getTrackersFromCollection(\n  trackerIds: Array<string>,\n  trackerCollection: Record<string, BrowserTracker>\n): Array<BrowserTracker> {\n  const trackers: Array<BrowserTracker> = [];\n  for (const id of trackerIds) {\n    if (trackerCollection.hasOwnProperty(id)) {\n      trackers.push(trackerCollection[id]);\n    } else {\n      LOG.warn(id + ' not configured');\n    }\n  }\n  return trackers;\n}\n","/*\n * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { addEventListener } from './helpers';\n\ndeclare global {\n  interface Document {\n    attachEvent: (type: string, fn: EventListenerOrEventListenerObject) => void;\n    detachEvent: (type: string, fn: EventListenerOrEventListenerObject) => void;\n  }\n}\n\n/**\n * A set of variables which are shared among all initialised trackers\n */\nexport class SharedState {\n  /* List of request queues - one per Tracker instance */\n  outQueues: Array<unknown> = [];\n  bufferFlushers: Array<(sync: boolean) => void> = [];\n\n  /* DOM Ready */\n  hasLoaded: boolean = false;\n  registeredOnLoadHandlers: Array<() => void> = [];\n\n  /* pageViewId, which can changed by other trackers on page;\n   * initialized by tracker sent first event */\n  pageViewId?: string;\n}\n\nexport function createSharedState(): SharedState {\n  const sharedState = new SharedState(),\n    documentAlias = document,\n    windowAlias = window;\n\n  /*\n   * Handle page visibility event\n   * Works everywhere except IE9\n   */\n  function visibilityChangeHandler() {\n    if (documentAlias.visibilityState == 'hidden') {\n      // Flush all POST queues\n      sharedState.bufferFlushers.forEach(function (flusher) {\n        flusher(false);\n      });\n    }\n  }\n\n  function flushBuffers() {\n    // Flush all POST queues\n    sharedState.bufferFlushers.forEach(function (flusher) {\n      flusher(false);\n    });\n  }\n\n  /*\n   * Handler for onload event\n   */\n  function loadHandler() {\n    var i;\n\n    if (!sharedState.hasLoaded) {\n      sharedState.hasLoaded = true;\n      for (i = 0; i < sharedState.registeredOnLoadHandlers.length; i++) {\n        sharedState.registeredOnLoadHandlers[i]();\n      }\n    }\n    return true;\n  }\n\n  /*\n   * Add onload or DOM ready handler\n   */\n  function addReadyListener() {\n    if (documentAlias.addEventListener) {\n      documentAlias.addEventListener('DOMContentLoaded', function ready() {\n        documentAlias.removeEventListener('DOMContentLoaded', ready, false);\n        loadHandler();\n      });\n    } else if (documentAlias.attachEvent) {\n      documentAlias.attachEvent('onreadystatechange', function ready() {\n        if (documentAlias.readyState === 'complete') {\n          documentAlias.detachEvent('onreadystatechange', ready);\n          loadHandler();\n        }\n      });\n    }\n\n    // fallback\n    addEventListener(windowAlias, 'load', loadHandler, false);\n  }\n\n  /************************************************************\n   * Constructor\n   ************************************************************/\n\n  // initialize the Snowplow singleton\n  if (documentAlias.visibilityState) {\n    // Flush for mobile and modern browsers\n    addEventListener(documentAlias, 'visibilitychange', visibilityChangeHandler, false);\n  }\n  // Last attempt at flushing in beforeunload\n  addEventListener(windowAlias, 'beforeunload', flushBuffers, false);\n\n  if (document.readyState === 'loading') {\n    addReadyListener();\n  } else {\n    loadHandler();\n  }\n\n  return sharedState;\n}\n"]},"metadata":{},"sourceType":"module"}